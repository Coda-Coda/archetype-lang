module Unanimity_storage
  use archetype.Lib
  
  use list.List as L
  
  use archetype.Field as F
  
  use archetype.View as V
  
  type _asset =
   | ASig
   | ASig_spec
  
  type _entry =
   | ECreate_sig
   | EUnanimity
   | EFailed
   | ESign
   | EClear_expired
  
  type _field =
   | FAdmin
   | FId_signatory
   | FValue
   | FSid
   | FSignatories
   | FDev
   | FExpiration
   | FSignatures
  
  clone archetype.Trace as Tr with type _asset = _asset,
                                   type _entry = _entry,
                                   type _field = _field
  
  let function eq_list0 (e1 : (address, int)) (e2 : (address, int)) : bool
  =  match (e1 , e2) with
     | ((e10),(e11)),((e20),(e21)) -> if ((str_eq e10 e20) && (e11 = e21)) then (
                                        true )
                                      else (
                                        false )
     |( _),( _) -> false 
     end
  
  clone archetype.List as List0 with type t = (address, int),
                                     val eqt = eq_list0
  
  let function eq_list1 (e1 : address) (e2 : address) : bool
  =  str_eq e1 e2
  
  clone archetype.List as List1 with type t = address,
                                     val eqt = eq_list1
  
  type sig = {
    id_signatory : (string, address);
    value : int 
  }
  
  let function eq_sig_key (k1 : (string, address)) (k2 : (string, address)) : bool
  =  match (k1 , k2) with
     | ((k10),(k11)),((k20),(k21)) -> if ((str_eq k10 k20) && (str_eq k11 k21)) then (
                                        true )
                                      else (
                                        false )
     |( _),( _) -> false 
     end
  
  let function eq_sig (a1 : sig) (a2 : sig) : bool
  =  (let a1_id_signatory = a1.id_signatory in
     let a2_id_signatory = a2.id_signatory in
     match (a1_id_signatory , a2_id_signatory) with
     | ((a1_id_signatory0),(a1_id_signatory1)),((a2_id_signatory0),(a2_id_signatory1)) -> if ((str_eq a1_id_signatory0 a2_id_signatory0) && (str_eq a1_id_signatory1 a2_id_signatory1)) then (
                                                                      true )
                                                                    else (
                                                                      false )
     |( _),( _) -> false 
     end && let a1_value = a1.value in
     let a2_value = a2.value in
     a1_value = a2_value)
  
  let mk_default_sig () : sig
  =  {
       id_signatory = ("" , "");
       value = 0
     }
  
  clone archetype.View as View_sig with type tk = (string, address),
                                        val eqk = eq_sig_key
  
  clone archetype.Field as Field_sig with type tk = (string, address),
                                          val eqk = eq_sig_key,
                                          type view = View_sig.view,
                                          val vmk = View_sig.mk,
                                          val velts = View_sig.elts,
                                          val vcontains = View_sig.contains
  
  clone archetype.Collection as Sig with type tk = (string, address),
                                         val eqk = eq_sig_key,
                                         type t = sig,
                                         val keyt = id_signatory,
                                         val eqt = eq_sig,
                                         type view = View_sig.view,
                                         val vmk = View_sig.mk,
                                         val velts = View_sig.elts,
                                         val vcontains = View_sig.contains,
                                         type field = Field_sig.field,
                                         val felts = Field_sig.elts
  
  type sig_spec = {
    sid : string;
    signatories : L.list address;
    dev : int;
    expiration : int;
    signatures : Field_sig.field 
  }
  
  let function eq_sig_spec_key (k1 : string) (k2 : string) : bool
  =  str_eq k1 k2
  
  let function eq_sig_spec (a1 : sig_spec) (a2 : sig_spec) : bool
  =  (((((((let a1_sid = a1.sid in
     let a2_sid = a2.sid in
     str_eq a1_sid a2_sid && let a1_signatories = a1.signatories in
     let a2_signatories = a2.signatories in
     List1.eq_list a1_signatories a2_signatories)) && let a1_dev = a1.dev in
     let a2_dev = a2.dev in
     a1_dev = a2_dev)) && let a1_expiration = a1.expiration in
     let a2_expiration = a2.expiration in
     a1_expiration = a2_expiration)) && let a1_signatures = a1.signatures in
     let a2_signatures = a2.signatures in
     Field_sig.eq a1_signatures a2_signatures)
  
  let mk_default_sig_spec () : sig_spec
  =  {
       sid = "";
       signatories = L.Nil;
       dev = 0;
       expiration = 0;
       signatures = Field_sig.empty
     }
  
  clone archetype.View as View_sig_spec with type tk = string,
                                             val eqk = eq_sig_spec_key
  
  clone archetype.Field as Field_sig_spec with type tk = string,
                                               val eqk = eq_sig_spec_key,
                                               type view = View_sig_spec.view,
                                               val vmk = View_sig_spec.mk,
                                               val velts = View_sig_spec.elts,
                                               val vcontains = View_sig_spec.contains
  
  clone archetype.Collection as Sig_spec with type tk = string,
                                              val eqk = eq_sig_spec_key,
                                              type t = sig_spec,
                                              val keyt = sid,
                                              val eqt = eq_sig_spec,
                                              type view = View_sig_spec.view,
                                              val vmk = View_sig_spec.mk,
                                              val velts = View_sig_spec.elts,
                                              val vcontains = View_sig_spec.contains,
                                              type field = Field_sig_spec.field,
                                              val felts = Field_sig_spec.elts
  
  lemma sig_extensionality:
    forall a1 a2 : sig.
    eq_sig a1 a2 ->
    a1 = a2 
  
  lemma sig_spec_extensionality:
    forall a1 a2 : sig_spec.
    eq_sig_spec a1 a2 ->
    a1 = a2 
  
  let function get_sig_sum1 (a : sig) : int
  =  a.value
  
  clone archetype.Sum as SigSum1 with type collection = Sig.collection,
                                      type view = View_sig.view,
                                      type t = sig,
                                      type tk = (string, address),
                                      val field = get_sig_sum1,
                                      val get = Sig.get,
                                      val elts = View_sig.elts,
                                      val mk = View_sig.mk,
                                      val card = View_sig.card
  
  let select_sig_spec_1 (_now : date) (v : View_sig_spec.view) (c : Sig_spec.collection) : View_sig_spec.view
  ensures {
    [@expl:select_sig_spec_1_post_1]
    forall k : string.
    View_sig_spec.contains k result ->
    forall a : sig_spec.
    (Sig_spec.get k c) = (Some a) ->
    a.expiration < _now   
  }
  ensures {
    [@expl:select_sig_spec_1_post_2]
    forall k : string.
    View_sig_spec.contains k result ->
    (Sig_spec.get k c) = None ->
    false    
  }
  =  let rec internal_select (l : L.list string) : L.list string
     variant { l }
     =  match l with
        | L.Nil -> L.Nil
        | L.Cons i tl -> 
          match Sig_spec.get i c with
          | Some a -> if a.expiration < _now then (
                        L.Cons a.sid (internal_select tl) )
                      else (
                        internal_select tl )
          | _ -> internal_select tl 
          end
        end in
     View_sig_spec.mk (internal_select (View_sig_spec.elts v))
  
  type _storage = {
    mutable admin : role;
    mutable _sig_assets : Sig.collection;
    mutable _sig_assets_added : Sig.collection;
    mutable _sig_assets_removed : Sig.collection;
    mutable _sig_spec_assets : Sig_spec.collection;
    mutable _sig_spec_assets_added : Sig_spec.collection;
    mutable _sig_spec_assets_removed : Sig_spec.collection;
    mutable _ops : L.list operation;
    mutable _balance : tez;
    _transferred : tez;
    _caller : address;
    _source : address;
    _now : date;
    _chainid : chain_id;
    _selfaddress : address;
    _entry : option _entry;
    mutable _tr : Tr._traces 
  } by {
    admin = "tz1ZXf37ZNfVupt5GVyrPJ76q8kbjFuD2z7R";
    _sig_assets = Sig.from_list (L.Nil);
    _sig_assets_added = Sig.empty;
    _sig_assets_removed = Sig.empty;
    _sig_spec_assets = Sig_spec.from_list (L.Nil);
    _sig_spec_assets_added = Sig_spec.empty;
    _sig_spec_assets_removed = Sig_spec.empty;
    _ops = L.Nil;
    _balance = 0;
    _transferred = 0;
    _caller = "";
    _source = "";
    _now = 0;
    _chainid = 0;
    _selfaddress = "";
    _entry = None;
    _tr = L.Nil 
  }
  
  val _s : _storage
  
  let transfer (a : int) (t : address) : unit
  ensures {
    [@expl:transfer_post_1]
    _s._balance = ((old _s)._balance - a)  
  }
  =  _s._ops <- L.Cons (_mk_transfer t a) _s._ops;
     _s._balance <- _s._balance - a
  
  let call (t : address) (a : tez) (n : string) (l : L.list string) : unit
  =  _s._ops <- L.Cons (_mk_call t a n l) _s._ops
  
  let mk_operation (a : tez) (e : entrysig) (l : L.list string) : unit
  =  _s._ops <- L.Cons (_mk_operation a e l) _s._ops
  
  let nth_sig (i : int) (v : View_sig.view) : (string, address)
  raises { NotFound }
  ensures {
    [@expl:nth_sig_post_1]
    View_sig.contains result v  
  }
  =  match View_sig.nth i v with
     | Some k -> k
     | _ -> raise NotFound 
     end
  
  let get_sig (k : (string, address)) : sig
  raises { NotFound ->
           (Sig.get k _s._sig_assets) = None  }
  ensures {
    [@expl:get_sig_post_1]
    (Sig.get k _s._sig_assets) = (Some result) 
  }
  ensures {
    [@expl:get_sig_post_2]
    result.id_signatory = k  
  }
  =  match Sig.get k _s._sig_assets with
     | Some e -> e
     | _ -> raise NotFound 
     end
  
  let add_sig (new_asset : sig) : unit
  raises { KeyExist ->
           (Sig.get new_asset.id_signatory (old _s)._sig_assets) = None  }
  ensures {
    [@expl:add_sig_post_1]
    (Sig.get new_asset.id_signatory (old _s)._sig_assets) = None 
  }
  ensures {
    [@expl:add_sig_post_2]
    forall k : (string, address).
    k <> new_asset.id_signatory ->
    (Sig.get new_asset.id_signatory _s._sig_assets) = (Sig.get new_asset.id_signatory (old _s)._sig_assets)  
  }
  ensures {
    [@expl:add_sig_post_3]
    (Sig.get new_asset.id_signatory _s._sig_assets) = (Some new_asset) 
  }
  ensures {
    [@expl:add_sig_post_4]
    (Sig.get new_asset.id_signatory (old _s)._sig_assets_added) = None 
  }
  ensures {
    [@expl:add_sig_post_5]
    forall k : (string, address).
    k <> new_asset.id_signatory ->
    (Sig.get new_asset.id_signatory _s._sig_assets_added) = (Sig.get new_asset.id_signatory (old _s)._sig_assets_added)  
  }
  ensures {
    [@expl:add_sig_post_6]
    (Sig.get new_asset.id_signatory _s._sig_assets_added) = (Some new_asset) 
  }
  ensures {
    [@expl:add_sig_sum_post]
    (SigSum1.sum (Sig.to_view _s._sig_assets) _s._sig_assets) = ((SigSum1.sum (Sig.to_view (old _s)._sig_assets) (old _s)._sig_assets) + (get_sig_sum1 new_asset)) 
  }
  ensures {
    [@expl:add_sig_count]
    (View_sig.card (Sig.to_view _s._sig_assets)) = ((View_sig.card (Sig.to_view (old _s)._sig_assets)) + 1)  
  }
  =  match Sig.get new_asset.id_signatory _s._sig_assets with
     | Some _ -> raise KeyExist
     | _ -> _s._sig_assets <- Sig.add new_asset _s._sig_assets;
            _s._sig_assets_added <- Sig.add new_asset _s._sig_assets_added 
     end
  
  let remove_sig (a : (string, address)) : unit
  ensures {
    [@expl:remove_sig_post1]
    forall k : (string, address).
    k <> a ->
    (Sig.get a _s._sig_assets) = (Sig.get a (old _s)._sig_assets)  
  }
  ensures {
    [@expl:remove_sig_post2]
    (Sig.get a _s._sig_assets) = None 
  }
  ensures {
    [@expl:remove_sig_post3]
    forall k : (string, address).
    k <> a ->
    (Sig.get a _s._sig_assets_removed) = (Sig.get a (old _s)._sig_assets_removed)  
  }
  ensures {
    [@expl:remove_sig_post4]
    forall r : sig.
    (Sig.get a (old _s)._sig_assets) = (Some r) ->
    (Sig.get a _s._sig_assets_removed) = (Some r)   
  }
  =  match Sig.get a _s._sig_assets with
     | Some e -> _s._sig_assets_removed <- Sig.add e _s._sig_assets_removed;
                 _s._sig_assets <- Sig.remove a _s._sig_assets
     | _ -> () 
     end
  
  let get_sig_spec (k : string) : sig_spec
  raises { NotFound ->
           (Sig_spec.get k _s._sig_spec_assets) = None  }
  ensures {
    [@expl:get_sig_spec_post_1]
    (Sig_spec.get k _s._sig_spec_assets) = (Some result) 
  }
  ensures {
    [@expl:get_sig_spec_post_2]
    result.sid = k  
  }
  =  match Sig_spec.get k _s._sig_spec_assets with
     | Some e -> e
     | _ -> raise NotFound 
     end
  
  let add_sig_spec (new_asset : sig_spec) : unit
  raises { KeyExist ->
           (Sig_spec.get new_asset.sid (old _s)._sig_spec_assets) = None  }
  ensures {
    [@expl:add_sig_spec_post_1]
    (Sig_spec.get new_asset.sid (old _s)._sig_spec_assets) = None 
  }
  ensures {
    [@expl:add_sig_spec_post_2]
    forall k : string.
    k <> new_asset.sid ->
    (Sig_spec.get new_asset.sid _s._sig_spec_assets) = (Sig_spec.get new_asset.sid (old _s)._sig_spec_assets)  
  }
  ensures {
    [@expl:add_sig_spec_post_3]
    (Sig_spec.get new_asset.sid _s._sig_spec_assets) = (Some new_asset) 
  }
  ensures {
    [@expl:add_sig_spec_post_4]
    (Sig_spec.get new_asset.sid (old _s)._sig_spec_assets_added) = None 
  }
  ensures {
    [@expl:add_sig_spec_post_5]
    forall k : string.
    k <> new_asset.sid ->
    (Sig_spec.get new_asset.sid _s._sig_spec_assets_added) = (Sig_spec.get new_asset.sid (old _s)._sig_spec_assets_added)  
  }
  ensures {
    [@expl:add_sig_spec_post_6]
    (Sig_spec.get new_asset.sid _s._sig_spec_assets_added) = (Some new_asset)  
  }
  =  match Sig_spec.get new_asset.sid _s._sig_spec_assets with
     | Some _ -> raise KeyExist
     | _ -> _s._sig_spec_assets <- Sig_spec.add new_asset _s._sig_spec_assets;
            _s._sig_spec_assets_added <- Sig_spec.add new_asset _s._sig_spec_assets_added 
     end
  
  let remove_sig_spec (a : string) : unit
  ensures {
    [@expl:remove_sig_spec_post1]
    forall k : string.
    k <> a ->
    (Sig_spec.get a _s._sig_spec_assets) = (Sig_spec.get a (old _s)._sig_spec_assets)  
  }
  ensures {
    [@expl:remove_sig_spec_post2]
    (Sig_spec.get a _s._sig_spec_assets) = None 
  }
  ensures {
    [@expl:remove_sig_spec_post3]
    forall k : string.
    k <> a ->
    (Sig_spec.get a _s._sig_spec_assets_removed) = (Sig_spec.get a (old _s)._sig_spec_assets_removed)  
  }
  ensures {
    [@expl:remove_sig_spec_post4]
    forall r : sig_spec.
    (Sig_spec.get a (old _s)._sig_spec_assets) = (Some r) ->
    (Sig_spec.get a _s._sig_spec_assets_removed) = (Some r)   
  }
  =  match Sig_spec.get a _s._sig_spec_assets with
     | Some e -> _s._sig_spec_assets_removed <- Sig_spec.add e _s._sig_spec_assets_removed;
                 _s._sig_spec_assets <- Sig_spec.remove a _s._sig_spec_assets
     | _ -> () 
     end
  
  let clear_view_sig_spec (v : View_sig_spec.view) : unit
  =  for i = 0 to View_sig_spec.card v do
     
       match View_sig_spec.nth i v with
       | Some k -> remove_sig_spec k
       | _ -> () 
       end
     done
  
  let add_sig_spec_signatures (asset_id : string) (new_asset : sig) : unit
  raises { NotFound ->
           (Sig_spec.get asset_id _s._sig_spec_assets) = None  }
  raises { KeyExist ->
           (Sig.get new_asset.id_signatory (old _s)._sig_assets) <> None  }
  ensures {
    [@expl:add_sig_spec_signatures_field_post1]
    forall k : string.
    k <> asset_id ->
    (Sig_spec.get k (old _s)._sig_spec_assets) = (Sig_spec.get k _s._sig_spec_assets)  
  }
  ensures {
    [@expl:add_sig_spec_signatures_field_post2]
    forall r : sig_spec.
    (Sig_spec.get asset_id (old _s)._sig_spec_assets) = (Some r) ->
    (Sig_spec.get asset_id _s._sig_spec_assets) = (Some ({ r with
      signatures = Field_sig.add new_asset.id_signatory r.signatures
    }))  
  }
  ensures {
    [@expl:add_sig_field_sum_post]
    forall r : sig_spec.
    (Sig_spec.get asset_id _s._sig_spec_assets) = (Some r) ->
    (SigSum1.sum (Field_sig.to_view (signatures r)) _s._sig_assets) = ((SigSum1.sum (Field_sig.to_view (signatures r)) (old _s)._sig_assets) + (get_sig_sum1 new_asset))  
  }
  ensures {
    [@expl:add_sig_field_count]
    forall r : sig_spec.
    (Sig_spec.get asset_id _s._sig_spec_assets) = (Some r) ->
    (View_sig.card (Field_sig.to_view (signatures r))) = ((View_sig.card (Field_sig.to_view (signatures r))) + 1)  
  }
  ensures {
    [@expl:add_sig_spec_signatures_post_1]
    (Sig.get new_asset.id_signatory (old _s)._sig_assets) = None 
  }
  ensures {
    [@expl:add_sig_spec_signatures_post_2]
    forall k : (string, address).
    k <> new_asset.id_signatory ->
    (Sig.get new_asset.id_signatory _s._sig_assets) = (Sig.get new_asset.id_signatory (old _s)._sig_assets)  
  }
  ensures {
    [@expl:add_sig_spec_signatures_post_3]
    (Sig.get new_asset.id_signatory _s._sig_assets) = (Some new_asset) 
  }
  ensures {
    [@expl:add_sig_spec_signatures_post_4]
    (Sig.get new_asset.id_signatory (old _s)._sig_assets_added) = None 
  }
  ensures {
    [@expl:add_sig_spec_signatures_post_5]
    forall k : (string, address).
    k <> new_asset.id_signatory ->
    (Sig.get new_asset.id_signatory _s._sig_assets_added) = (Sig.get new_asset.id_signatory (old _s)._sig_assets_added)  
  }
  ensures {
    [@expl:add_sig_spec_signatures_post_6]
    (Sig.get new_asset.id_signatory _s._sig_assets_added) = (Some new_asset) 
  }
  ensures {
    [@expl:add_sig_sum_post]
    (SigSum1.sum (Sig.to_view _s._sig_assets) _s._sig_assets) = ((SigSum1.sum (Sig.to_view (old _s)._sig_assets) (old _s)._sig_assets) + (get_sig_sum1 new_asset)) 
  }
  ensures {
    [@expl:add_sig_count]
    (View_sig.card (Sig.to_view _s._sig_assets)) = ((View_sig.card (Sig.to_view (old _s)._sig_assets)) + 1)  
  }
  =  match Sig_spec.get asset_id _s._sig_spec_assets with
     | Some asset -> add_sig new_asset;
                     let sig_spec_signatures = signatures asset in
                     let new_sig_spec_signatures = Field_sig.add new_asset.id_signatory sig_spec_signatures in
                     let new_asset = { asset with
                       signatures = new_sig_spec_signatures
                     } in
                     _s._sig_spec_assets <- Sig_spec.set asset_id new_asset _s._sig_spec_assets
     | _ -> raise NotFound 
     end
end
module Unanimity
  use archetype.Lib
  
  use list.List as L
  
  use Unanimity_storage
  
  let get_signatures (spid : string) : L.list (address, int)
  raises { NotFound }
  =  let ref l = L.Nil in
     (let col_loop_get_signatures_0_ = (get_sig_spec spid).signatures in
      for _i_loop_get_signatures_0 = 0 to View_sig.card (Field_sig.to_view col_loop_get_signatures_0_) do
      
        let s = nth_sig _i_loop_get_signatures_0 (Field_sig.to_view col_loop_get_signatures_0_) in
        l <- List0.prepend ((nth2_of_2 (get_sig s).id_signatory , (get_sig s).value)) l
      done;
      l)
  
  let check_sig_data (spid : string) : bool
  raises { NotFound }
  =  let avg = rat_arith OpArithDiv ((SigSum1.sum (Field_sig.to_view (get_sig_spec spid).signatures) _s._sig_assets , 1)) ((View_sig.card (Field_sig.to_view (get_sig_spec spid).signatures) , 1)) in
     let min = rat_arith OpArithMult (rat_arith OpArithMinus ((1 , 1)) (rat_arith OpArithDiv (((get_sig_spec spid).dev , 1)) ((200 , 1)))) avg in
     let max = rat_arith OpArithMult (rat_arith OpArithPlus ((1 , 1)) (rat_arith OpArithDiv (((get_sig_spec spid).dev , 1)) ((200 , 1)))) avg in
     let ref _check = true in
     (let col_loop_check_sig_data_0_ = (get_sig_spec spid).signatures in
      for _i_loop_check_sig_data_0 = 0 to View_sig.card (Field_sig.to_view col_loop_check_sig_data_0_) do
      
        let s = nth_sig _i_loop_check_sig_data_0 (Field_sig.to_view col_loop_check_sig_data_0_) in
        _check <- (_check && (((rat_cmp OpCmpLe min (((get_sig s).value , 1))) && (rat_cmp OpCmpLe (((get_sig s).value , 1)) max))))
      done;
      _check)
  
  let create_sig (i : string) (s : L.list address) (d : int) : unit
  raises { InvalidCaller }
  raises { KeyExist }
  requires {
    [@expl:entry_require]
    _s._entry = (Some ECreate_sig) 
  }
  requires {
   [@expl:empty_trace]
   _s._tr = L.Nil  
  }
  =  if not (str_eq (_s._caller) _s.admin) then raise InvalidCaller;
     add_sig_spec ({
       sid = i;
       signatories = s;
       dev = d;
       expiration = (_s._now) + 86400;
       signatures = Field_sig.empty
     });
     _s._tr <- L.Cons (Tr.TrAdd_ ASig_spec) _s._tr
  
  let unanimity (spid : string) (l : L.list (address, int)) (d : int) : unit
  raises { InvalidCaller }
  requires {
    [@expl:entry_require]
    _s._entry = (Some EUnanimity) 
  }
  requires {
   [@expl:empty_trace]
   _s._tr = L.Nil  
  }
  =  if not (str_eq (_s._caller) _s._selfaddress) then raise InvalidCaller
  
  let failed (spid : string) (l : L.list (address, int)) (d : int) : unit
  raises { InvalidCaller }
  requires {
    [@expl:entry_require]
    _s._entry = (Some EFailed) 
  }
  requires {
   [@expl:empty_trace]
   _s._tr = L.Nil  
  }
  =  if not (str_eq (_s._caller) _s._selfaddress) then raise InvalidCaller
  
  let sign (spid : string) (v : int) : unit
  raises { InvalidCondition }
  raises { KeyExist }
  raises { NotFound }
  requires {
    [@expl:entry_require]
    _s._entry = (Some ESign) 
  }
  requires {
   [@expl:empty_trace]
   _s._tr = L.Nil  
  }
  =  if not (List1.contains (_s._caller) (get_sig_spec spid).signatories) then raise InvalidCondition;
     add_sig_spec_signatures spid ({
       id_signatory = (spid , _s._caller);
       value = v
     });
     _s._tr <- L.Cons (Tr.TrUpdate_ FSignatures) _s._tr;
     _s._tr <- L.Cons (Tr.TrAdd_ ASig) _s._tr;
     if (View_sig.card (Field_sig.to_view (get_sig_spec spid).signatures)) = (List1.card (get_sig_spec spid).signatories)
     then let sigs = get_signatures spid in
     let d = (get_sig_spec spid).dev in
     let selfentry = if check_sig_data spid then (
                       getopt (entrypoint "unanimity" "") )
                     else (
                       getopt (entrypoint "failed" "") ) in
     (mk_operation 0 selfentry L.Nil;
      remove_sig_spec spid;
      _s._tr <- L.Cons (Tr.TrRm_ ASig_spec) _s._tr)
  
  let clear_expired () : unit
  raises { InvalidCaller }
  requires {
    [@expl:entry_require]
    _s._entry = (Some EClear_expired) 
  }
  requires {
   [@expl:empty_trace]
   _s._tr = L.Nil  
  }
  =  if not (str_eq (_s._caller) _s.admin) then raise InvalidCaller;
     clear_view_sig_spec (select_sig_spec_1 (_s._now) (Sig_spec.to_view _s._sig_spec_assets) _s._sig_spec_assets)
end

