(** Liquidity driver *)

printer "liquidity"

prelude "[%%version 1.01]\n
let[@inline] empty_ops = ([] : operation list)

let[@inline] list_add (e, l) = e::l

let[@inline] keyh_to_addr (iKeyh : key_hash) = Contract.address (Account.default iKeyh)"

module HighOrd
  syntax type (->) "%1 -> %2"
  syntax val  ( @ )  "%1 %2"
end

theory option.Option
  syntax type     option "%1 option"
  syntax function None   "None"
  syntax function Some   "Some %1"
end

theory Bool
  syntax type     bool  "bool"
  syntax function True  "true"
  syntax function False "false"
end

theory bool.Ite
  syntax function ite "(if %1 then %2 else %3)"
end

theory bool.Bool
  syntax function andb  "%1 && %2"
  syntax function orb   "%1 || %2"
  syntax function xorb  "%1 <> %2"
  syntax function notb  "not %1"
  syntax function implb "not %1 || %2"
end

module liq.Int
  syntax val toint      "%1:int"
end

module liq.Nat

  syntax val tonat     "%1:nat"
  syntax val nat_zero  "(0:nat)"
  syntax val nat_one   "(1:nat)"

  syntax val nat_eq    "%1 = %2"
  syntax val nat_nq   "%1 <> %2"

  syntax val nat_ge    "%1 >= %2"
  syntax val nat_le    "%1 <= %2"
  syntax val nat_gt    "%1 > %2"
  syntax val nat_lt    "%1 < %2"

end

module liq.Tez
  syntax val totez     "%1tz:tez"
end

module liq.Address

  syntax val toaddress "%1:address"

  syntax val add_eq    "%1 = %2"
  syntax val add_nq    "%1 <> %2"

end

module liq.Timestamp
  syntax val tim_eq    "%1 = %2"
  syntax val tim_nq    "%1 <> %2"

  syntax val tim_ge    "%1 >= %2"
  syntax val tim_le    "%1 <= %2"
  syntax val tim_gt    "%1 > %2"
  syntax val tim_lt    "%1 < %2"
end

module liq.Utils

  syntax val get_0_2   "get %1 0"
  syntax val get_1_2   "get %1 1"

  syntax val get_0_3   "get %1 0"
  syntax val get_1_3   "get %1 1"
  syntax val get_2_3   "get %1 2"

  syntax val get_0_4   "get %1 0"
  syntax val get_1_4   "get %1 1"
  syntax val get_2_4   "get %1 2"
  syntax val get_3_4   "get %1 3"

  syntax val get_0_5   "get %1 0"
  syntax val get_1_5   "get %1 1"
  syntax val get_2_5   "get %1 2"
  syntax val get_3_5   "get %1 3"
  syntax val get_4_5   "get %1 4"

  syntax val get_0_6   "get %1 0"
  syntax val get_1_6   "get %1 1"
  syntax val get_2_6   "get %1 2"
  syntax val get_3_6   "get %1 3"
  syntax val get_4_6   "get %1 4"
  syntax val get_5_6   "get %1 5"

  syntax val update_storage "%2 <- %3"
  syntax val update_simple "%2"

end

module liq.Msg

  syntax val not_found          "\"not found\""
  syntax val not_supported_yet  "\"not supported yet\""
  syntax val already_exists     "\"already exists\""

end

module liq.List

  syntax val fold "List.fold %1 %2 %3"

  syntax val mem "list_mem %1"

  syntax val append "list_append %1"

  syntax val add "list_add %1"

  syntax val remove "list_remove %1"

  syntax val Nil "[]"

end

module liq.Map

  syntax val find       "Map.find %1 %2"

  syntax val mem        "Map.mem %1 %2"

  syntax val add        "Map.add %1 %2 %3"

  syntax val remove     "Map.remove %1 %2"

  syntax val update     "Map.update %1 %2 %3"

  syntax val empty_map  "empty_map"

end

module liq.Set

  syntax val mem           "Set.mem %1 %2"

  syntax val add           "Set.add %1 %2"

  syntax val remove        "Set.remove %1 %2"

  syntax val empty_set     "empty_set"

end

module liq.Current

  syntax val failwith  "Current.failwith %1"

end
