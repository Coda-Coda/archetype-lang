module Fa12_storage
  use archetype.Lib
  
  use list.List as L
  
  use archetype.Field as F
  
  use archetype.View as V
  
  type _asset =
   | AAllowance
   | ALedger
  
  type _entry =
   | ETransfer
   | EApprove
   | EGetAllowance
   | EGetBalance
   | EGetTotalSupply
  
  type _field =
   | FTotalsupply
   | FAddr_owner_addr_spender
   | FAmount
   | FHolder
   | FTokens
  
  clone archetype.Trace as Tr with type _asset = _asset,
                                   type _entry = _entry,
                                   type _field = _field
  
  type allowance = {
    addr_owner_addr_spender : (address, address);
    amount : uint 
  }
  
  let function eq_allowance_key (k1 : (address, address)) (k2 : (address, address)) : bool
  =  match (k1 , k2) with
     | ((k10),(k11)),((k20),(k21)) -> if ((str_eq k10 k20) && (str_eq k11 k21)) then (
                                        true )
                                      else (
                                        false )
     |( _),( _) -> false 
     end
  
  let function eq_allowance (a1 : allowance) (a2 : allowance) : bool
  =  (let a1_addr_owner_addr_spender = a1.addr_owner_addr_spender in
     let a2_addr_owner_addr_spender = a2.addr_owner_addr_spender in
     match (a1_addr_owner_addr_spender , a2_addr_owner_addr_spender) with
     | ((a1_addr_owner_addr_spender0),(a1_addr_owner_addr_spender1)),((a2_addr_owner_addr_spender0),(a2_addr_owner_addr_spender1)) -> 
     if ((str_eq a1_addr_owner_addr_spender0 a2_addr_owner_addr_spender0) && (str_eq a1_addr_owner_addr_spender1 a2_addr_owner_addr_spender1)) then (
       true )
     else (
       false )
     |( _),( _) -> false 
     end && let a1_amount = a1.amount in
     let a2_amount = a2.amount in
     a1_amount = a2_amount)
  
  let mk_default_allowance () : allowance
  =  {
       addr_owner_addr_spender = ("" , "");
       amount = 0
     }
  
  clone archetype.View as View_allowance with type tk = (address, address),
                                              val eqk = eq_allowance_key
  
  clone archetype.Field as Field_allowance with type tk = (address, address),
                                                val eqk = eq_allowance_key,
                                                type view = View_allowance.view,
                                                val vmk = View_allowance.mk,
                                                val velts = View_allowance.elts,
                                                val vcontains = View_allowance.contains
  
  clone archetype.Collection as Allowance with type tk = (address, address),
                                               val eqk = eq_allowance_key,
                                               type t = allowance,
                                               val keyt = addr_owner_addr_spender,
                                               val eqt = eq_allowance,
                                               type view = View_allowance.view,
                                               val vmk = View_allowance.mk,
                                               val velts = View_allowance.elts,
                                               val vcontains = View_allowance.contains,
                                               type field = Field_allowance.field,
                                               val felts = Field_allowance.elts
  
  type ledger = {
    holder : address;
    tokens : uint 
  }
  
  let function eq_ledger_key (k1 : address) (k2 : address) : bool
  =  str_eq k1 k2
  
  let function eq_ledger (a1 : ledger) (a2 : ledger) : bool
  =  (let a1_holder = a1.holder in
     let a2_holder = a2.holder in
     str_eq a1_holder a2_holder && let a1_tokens = a1.tokens in
     let a2_tokens = a2.tokens in
     a1_tokens = a2_tokens)
  
  let mk_default_ledger () : ledger
  =  {
       holder = "";
       tokens = 0
     }
  
  clone archetype.View as View_ledger with type tk = address,
                                           val eqk = eq_ledger_key
  
  clone archetype.Field as Field_ledger with type tk = address,
                                             val eqk = eq_ledger_key,
                                             type view = View_ledger.view,
                                             val vmk = View_ledger.mk,
                                             val velts = View_ledger.elts,
                                             val vcontains = View_ledger.contains
  
  clone archetype.Collection as Ledger with type tk = address,
                                            val eqk = eq_ledger_key,
                                            type t = ledger,
                                            val keyt = holder,
                                            val eqt = eq_ledger,
                                            type view = View_ledger.view,
                                            val vmk = View_ledger.mk,
                                            val velts = View_ledger.elts,
                                            val vcontains = View_ledger.contains,
                                            type field = Field_ledger.field,
                                            val felts = Field_ledger.elts
  
  lemma allowance_extensionality:
    forall a1 a2 : allowance.
    eq_allowance a1 a2 ->
    a1 = a2 
  
  lemma ledger_extensionality:
    forall a1 a2 : ledger.
    eq_ledger a1 a2 ->
    a1 = a2 
  
  let function get_ledger_sum1 (a : ledger) : int
  =  a.tokens
  
  clone archetype.Sum as LedgerSum1 with type collection = Ledger.collection,
                                         type view = View_ledger.view,
                                         type t = ledger,
                                         type tk = address,
                                         val field = get_ledger_sum1,
                                         val get = Ledger.get,
                                         val elts = View_ledger.elts,
                                         val mk = View_ledger.mk,
                                         val card = View_ledger.card
  
  type _storage = {
    mutable totalsupply : uint;
    mutable _allowance_assets : Allowance.collection;
    mutable _allowance_assets_added : Allowance.collection;
    mutable _allowance_assets_removed : Allowance.collection;
    mutable _ledger_assets : Ledger.collection;
    mutable _ledger_assets_added : Ledger.collection;
    mutable _ledger_assets_removed : Ledger.collection;
    mutable _ops : L.list operation;
    mutable _balance : tez;
    _transferred : tez;
    _caller : address;
    _source : address;
    _now : date;
    _chainid : chain_id;
    _selfaddress : address;
    _entry : option _entry;
    mutable _tr : Tr._traces 
  } invariant {
    [@expl:s1]
    (LedgerSum1.sum_formula _ledger_assets) = totalsupply  
  } by {
    totalsupply = 10000000;
    _allowance_assets = Allowance.from_list (L.Nil);
    _allowance_assets_added = Allowance.empty;
    _allowance_assets_removed = Allowance.empty;
    _ledger_assets = Ledger.from_list (L.Cons ({
      holder = "tz1Lc2qBKEWCBeDU8npG6zCeCqpmaegRi6Jg";
      tokens = 10000000
    }) (L.Nil));
    _ledger_assets_added = Ledger.empty;
    _ledger_assets_removed = Ledger.empty;
    _ops = L.Nil;
    _balance = 0;
    _transferred = 0;
    _caller = "";
    _source = "";
    _now = 0;
    _chainid = 0;
    _selfaddress = "";
    _entry = None;
    _tr = L.Nil 
  }
  
  val _s : _storage
  
  let transfer (a : int) (t : address) : unit
  ensures {
    [@expl:transfer_post_1]
    _s._balance = ((old _s)._balance - a)  
  }
  =  _s._ops <- L.Cons (_mk_transfer t a) _s._ops;
     _s._balance <- _s._balance - a
  
  let call (t : address) (a : tez) (n : string) (l : L.list string) : unit
  =  _s._ops <- L.Cons (_mk_call t a n l) _s._ops
  
  let mk_operation (a : tez) (e : entrysig) (l : L.list string) : unit
  =  _s._ops <- L.Cons (_mk_operation a e l) _s._ops
  
  let get_allowance (k : (address, address)) : allowance
  raises { NotFound ->
           (Allowance.get k _s._allowance_assets) = None  }
  ensures {
    [@expl:get_allowance_post_1]
    (Allowance.get k _s._allowance_assets) = (Some result) 
  }
  ensures {
    [@expl:get_allowance_post_2]
    result.addr_owner_addr_spender = k  
  }
  =  match Allowance.get k _s._allowance_assets with
     | Some e -> e
     | _ -> raise NotFound 
     end
  
  let set_allowance (asset_id : (address, address)) (new_asset : allowance) : unit
  raises { NotFound ->
           (Allowance.get asset_id _s._allowance_assets) = None  }
  ensures {
    [@expl:set_allowance_post1]
    (Allowance.get asset_id _s._allowance_assets) = (Some new_asset) 
  }
  ensures {
    [@expl:set_allowance_post2]
    forall k : (address, address).
    k <> asset_id ->
    (Allowance.get k _s._allowance_assets) = (Allowance.get k (old _s)._allowance_assets)   
  }
  =  match Allowance.get asset_id _s._allowance_assets with
     | Some _ -> _s._allowance_assets <- Allowance.set asset_id new_asset _s._allowance_assets
     | _ -> raise NotFound 
     end
  
  let add_allowance (new_asset : allowance) : unit
  raises { KeyExist ->
           (Allowance.get new_asset.addr_owner_addr_spender (old _s)._allowance_assets) = None  }
  ensures {
    [@expl:add_allowance_post_1]
    (Allowance.get new_asset.addr_owner_addr_spender (old _s)._allowance_assets) = None 
  }
  ensures {
    [@expl:add_allowance_post_2]
    forall k : (address, address).
    k <> new_asset.addr_owner_addr_spender ->
    (Allowance.get new_asset.addr_owner_addr_spender _s._allowance_assets) = (Allowance.get new_asset.addr_owner_addr_spender (old _s)._allowance_assets)  
  }
  ensures {
    [@expl:add_allowance_post_3]
    (Allowance.get new_asset.addr_owner_addr_spender _s._allowance_assets) = (Some new_asset) 
  }
  ensures {
    [@expl:add_allowance_post_4]
    (Allowance.get new_asset.addr_owner_addr_spender (old _s)._allowance_assets_added) = None 
  }
  ensures {
    [@expl:add_allowance_post_5]
    forall k : (address, address).
    k <> new_asset.addr_owner_addr_spender ->
    (Allowance.get new_asset.addr_owner_addr_spender _s._allowance_assets_added) = (Allowance.get new_asset.addr_owner_addr_spender (old _s)._allowance_assets_added)  
  }
  ensures {
    [@expl:add_allowance_post_6]
    (Allowance.get new_asset.addr_owner_addr_spender _s._allowance_assets_added) = (Some new_asset)  
  }
  =  match Allowance.get new_asset.addr_owner_addr_spender _s._allowance_assets with
     | Some _ -> raise KeyExist
     | _ -> _s._allowance_assets <- Allowance.add new_asset _s._allowance_assets;
            _s._allowance_assets_added <- Allowance.add new_asset _s._allowance_assets_added 
     end
  
  let get_ledger (k : address) : ledger
  raises { NotFound ->
           (Ledger.get k _s._ledger_assets) = None  }
  ensures {
    [@expl:get_ledger_post_1]
    (Ledger.get k _s._ledger_assets) = (Some result) 
  }
  ensures {
    [@expl:get_ledger_post_2]
    result.holder = k  
  }
  =  match Ledger.get k _s._ledger_assets with
     | Some e -> e
     | _ -> raise NotFound 
     end
  
  let set_ledger (asset_id : address) (new_asset : ledger) : unit
  raises { NotFound ->
           (Ledger.get asset_id _s._ledger_assets) = None  }
  ensures {
    [@expl:set_ledger_post1]
    (Ledger.get asset_id _s._ledger_assets) = (Some new_asset) 
  }
  ensures {
    [@expl:set_ledger_post2]
    forall k : address.
    k <> asset_id ->
    (Ledger.get k _s._ledger_assets) = (Ledger.get k (old _s)._ledger_assets)  
  }
  ensures {
    [@expl:set_ledger_sum_post]
    exists asset : ledger.
    (Ledger.get asset_id _s._ledger_assets) = (Some asset) /\ (LedgerSum1.sum (Ledger.to_view (old _s)._ledger_assets) (old _s)._ledger_assets) = (((LedgerSum1.sum (Ledger.to_view _s._ledger_assets) _s._ledger_assets) - (get_ledger_sum1 new_asset)) + (get_ledger_sum1 asset))  
  }
  =  match Ledger.get asset_id _s._ledger_assets with
     | Some _ -> _s._ledger_assets <- Ledger.set asset_id new_asset _s._ledger_assets
     | _ -> raise NotFound 
     end
  
  let add_ledger (new_asset : ledger) : unit
  raises { KeyExist ->
           (Ledger.get new_asset.holder (old _s)._ledger_assets) = None  }
  ensures {
    [@expl:add_ledger_post_1]
    (Ledger.get new_asset.holder (old _s)._ledger_assets) = None 
  }
  ensures {
    [@expl:add_ledger_post_2]
    forall k : address.
    k <> new_asset.holder ->
    (Ledger.get new_asset.holder _s._ledger_assets) = (Ledger.get new_asset.holder (old _s)._ledger_assets)  
  }
  ensures {
    [@expl:add_ledger_post_3]
    (Ledger.get new_asset.holder _s._ledger_assets) = (Some new_asset) 
  }
  ensures {
    [@expl:add_ledger_post_4]
    (Ledger.get new_asset.holder (old _s)._ledger_assets_added) = None 
  }
  ensures {
    [@expl:add_ledger_post_5]
    forall k : address.
    k <> new_asset.holder ->
    (Ledger.get new_asset.holder _s._ledger_assets_added) = (Ledger.get new_asset.holder (old _s)._ledger_assets_added)  
  }
  ensures {
    [@expl:add_ledger_post_6]
    (Ledger.get new_asset.holder _s._ledger_assets_added) = (Some new_asset) 
  }
  ensures {
    [@expl:add_ledger_sum_post]
    (LedgerSum1.sum (Ledger.to_view _s._ledger_assets) _s._ledger_assets) = ((LedgerSum1.sum (Ledger.to_view (old _s)._ledger_assets) (old _s)._ledger_assets) + (get_ledger_sum1 new_asset))  
  }
  =  match Ledger.get new_asset.holder _s._ledger_assets with
     | Some _ -> raise KeyExist
     | _ -> _s._ledger_assets <- Ledger.add new_asset _s._ledger_assets;
            _s._ledger_assets_added <- Ledger.add new_asset _s._ledger_assets_added 
     end
end
module Fa12
  use archetype.Lib
  
  use list.List as L
  
  use Fa12_storage
  
  let transfer (from_ : address) (to_ : address) (value : uint) : unit
  raises { InvalidCondition }
  raises { NotFound }
  raises { KeyExist }
  requires {
    [@expl:entry_require]
    _s._entry = (Some ETransfer) 
  }
  requires {
   [@expl:empty_trace]
   _s._tr = L.Nil  
  }
  =  if not ((get_ledger from_).tokens >= value) then raise InvalidCondition;
     if not (str_eq (_s._caller) from_)
     then (if not ((get_allowance ((from_ , _s._caller))).amount >= value) then raise InvalidCondition;
           let allowance_ = get_allowance ((from_ , _s._caller)) in
           let allowance_ = {
             addr_owner_addr_spender = allowance_.addr_owner_addr_spender;
             amount = abs (allowance_.amount - value)
           } in
           (set_allowance ((from_ , _s._caller)) allowance_;
            _s._tr <- L.Cons (Tr.TrUpdate_ FAmount) _s._tr));
     let ledger_ = get_ledger from_ in
     let ledger_ = {
       holder = ledger_.holder;
       tokens = abs (ledger_.tokens - value)
     } in
     (set_ledger from_ ledger_;
      _s._tr <- L.Cons (Tr.TrUpdate_ FTokens) _s._tr);
     if View_ledger.contains to_ (Ledger.to_view _s._ledger_assets) then (
       let ledger_ = get_ledger to_ in
       let ledger_ = {
         holder = ledger_.holder;
         tokens = ledger_.tokens + value
       } in
       (set_ledger to_ ledger_;
        _s._tr <- L.Cons (Tr.TrUpdate_ FTokens) _s._tr) )
     else (
       (add_ledger ({
          holder = to_;
          tokens = 0 + value
        });
        _s._tr <- L.Cons (Tr.TrAdd_ ALedger) _s._tr) )
  
  let approve (spender : address) (value : uint) : unit
  raises { NotFound }
  raises { KeyExist }
  requires {
    [@expl:entry_require]
    _s._entry = (Some EApprove) 
  }
  requires {
   [@expl:empty_trace]
   _s._tr = L.Nil  
  }
  =  if View_allowance.contains ((_s._caller , spender)) (Allowance.to_view _s._allowance_assets) then (
       let allowance_ = get_allowance ((_s._caller , spender)) in
       let allowance_ = {
         addr_owner_addr_spender = allowance_.addr_owner_addr_spender;
         amount = value
       } in
       (set_allowance ((_s._caller , spender)) allowance_;
        _s._tr <- L.Cons (Tr.TrUpdate_ FAmount) _s._tr) )
     else (
       (add_allowance ({
          addr_owner_addr_spender = (_s._caller , spender);
          amount = value
        });
        _s._tr <- L.Cons (Tr.TrAdd_ AAllowance) _s._tr) )
  
  let getAllowance (owner : address) (spender : address) (cb : entrysig) : unit
  requires {
    [@expl:entry_require]
    _s._entry = (Some EGetAllowance) 
  }
  requires {
   [@expl:empty_trace]
   _s._tr = L.Nil  
  }
  =  mk_operation 0 cb L.Nil
  
  let getBalance (owner : address) (cb : entrysig) : unit
  requires {
    [@expl:entry_require]
    _s._entry = (Some EGetBalance) 
  }
  requires {
   [@expl:empty_trace]
   _s._tr = L.Nil  
  }
  =  mk_operation 0 cb L.Nil
  
  let getTotalSupply (cb : entrysig) : unit
  requires {
    [@expl:entry_require]
    _s._entry = (Some EGetTotalSupply) 
  }
  requires {
   [@expl:empty_trace]
   _s._tr = L.Nil  
  }
  =  mk_operation 0 cb L.Nil
end

