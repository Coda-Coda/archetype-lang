module Effect_method_asset_removeif_partition_storage
  use archetype.Lib
  
  use list.List as L
  
  use archetype.Field as F
  
  use archetype.View as V
  
  type _asset =
   | AO_asset
   | AMy_asset
  
  type _entry =
   | EExec
  
  type _field =
   | FOid
   | F_val
   | FId
   | FCol
  
  clone archetype.Trace as Tr with type _asset = _asset,
                                   type _entry = _entry,
                                   type _field = _field
  
  type o_asset = {
    oid : int;
    _val : int 
  }
  
  let function eq_o_asset_key (k1 : int) (k2 : int) : bool
  =  k1 = k2
  
  let function le_o_asset_key (k1 : int) (k2 : int) : bool
  =  k1 <= k2
  
  let function eq_o_asset (a1 : o_asset) (a2 : o_asset) : bool
  =  (let a1_oid = a1.oid in
     let a2_oid = a2.oid in
     a1_oid = a2_oid && let a1__val = a1._val in
     let a2__val = a2._val in
     a1__val = a2__val)
  
  let mk_default_o_asset () : o_asset
  =  {
       oid = 0;
       _val = 0
     }
  
  clone archetype.View as View_o_asset with type tk = int,
                                            val eqk = eq_o_asset_key
  
  clone archetype.Field as Field_o_asset with type tk = int,
                                              val eqk = eq_o_asset_key,
                                              val lek = le_o_asset_key,
                                              type view = View_o_asset.view,
                                              val vmk = View_o_asset.mk,
                                              val velts = View_o_asset.elts,
                                              val vcontains = View_o_asset.contains
  
  clone archetype.Collection as O_asset with type tk = int,
                                             val eqk = eq_o_asset_key,
                                             val lek = le_o_asset_key,
                                             type t = o_asset,
                                             val keyt = oid,
                                             val eqt = eq_o_asset,
                                             type view = View_o_asset.view,
                                             val vmk = View_o_asset.mk,
                                             val velts = View_o_asset.elts,
                                             val vcontains = View_o_asset.contains,
                                             type field = Field_o_asset.field,
                                             val felts = Field_o_asset.elts,
                                             val fcontains = Field_o_asset.contains
  
  type my_asset = {
    id : arstring;
    col : Field_o_asset.field 
  }
  
  let function eq_my_asset_key (k1 : arstring) (k2 : arstring) : bool
  =  str_eq k1 k2
  
  let function le_my_asset_key (k1 : arstring) (k2 : arstring) : bool
  =  str_le k1 k2
  
  let function eq_my_asset (a1 : my_asset) (a2 : my_asset) : bool
  =  (let a1_id = a1.id in
     let a2_id = a2.id in
     str_eq a1_id a2_id && let a1_col = a1.col in
     let a2_col = a2.col in
     Field_o_asset.eq a1_col a2_col)
  
  let mk_default_my_asset () : my_asset
  =  {
       id = "";
       col = Field_o_asset.empty
     }
  
  clone archetype.View as View_my_asset with type tk = arstring,
                                             val eqk = eq_my_asset_key
  
  clone archetype.Field as Field_my_asset with type tk = arstring,
                                               val eqk = eq_my_asset_key,
                                               val lek = le_my_asset_key,
                                               type view = View_my_asset.view,
                                               val vmk = View_my_asset.mk,
                                               val velts = View_my_asset.elts,
                                               val vcontains = View_my_asset.contains
  
  clone archetype.Collection as My_asset with type tk = arstring,
                                              val eqk = eq_my_asset_key,
                                              val lek = le_my_asset_key,
                                              type t = my_asset,
                                              val keyt = id,
                                              val eqt = eq_my_asset,
                                              type view = View_my_asset.view,
                                              val vmk = View_my_asset.mk,
                                              val velts = View_my_asset.elts,
                                              val vcontains = View_my_asset.contains,
                                              type field = Field_my_asset.field,
                                              val felts = Field_my_asset.elts,
                                              val fcontains = Field_my_asset.contains
  
  let function set_col (f : Field_o_asset.field) (a : my_asset) : my_asset
  =  { a with
       col = f
     }
  
  clone archetype.Aggregate as Aggregate_col with type t = my_asset,
                                                  type tk = arstring,
                                                  type collection = My_asset.collection,
                                                  val elts = My_asset.elts,
                                                  val get = My_asset.get,
                                                  val set = My_asset.set,
                                                  type field = Field_o_asset.field,
                                                  val setF = set_col,
                                                  val aggregate = col,
                                                  type tkF = int,
                                                  val containsF = Field_o_asset.contains,
                                                  val mkF = Field_o_asset.mk,
                                                  val eltsF = Field_o_asset.elts,
                                                  val addF = Field_o_asset.add,
                                                  val removeF = Field_o_asset.remove,
                                                  val emptyF = Field_o_asset.empty,
                                                  type tO = o_asset,
                                                  type collectionO = O_asset.collection,
                                                  val getO = O_asset.get
  
  let function removeif_o_asset_0 (a : o_asset) : bool
  ensures {
    [@expl:removeif_o_asset_0_post]
    result = (a._val = 0)  
  }
  =  a._val = 0
  
  type _storage = {
    mutable _o_asset_assets : O_asset.collection;
    mutable _o_asset_assets_added : O_asset.collection;
    mutable _o_asset_assets_removed : O_asset.collection;
    mutable _my_asset_assets : My_asset.collection;
    mutable _my_asset_assets_added : My_asset.collection;
    mutable _my_asset_assets_removed : My_asset.collection;
    mutable _ops : L.list operation;
    mutable _balance : tez;
    _transferred : tez;
    _caller : address;
    _source : address;
    _now : date;
    _chainid : chain_id;
    _selfaddress : address;
    _entry : option _entry;
    mutable _tr : Tr._traces 
  } by {
    _o_asset_assets = O_asset.from_list (L.Nil);
    _o_asset_assets_added = O_asset.empty;
    _o_asset_assets_removed = O_asset.empty;
    _my_asset_assets = My_asset.from_list (L.Cons ({
      id = "id0";
      col = Field_o_asset.empty
    }) (L.Cons ({
      id = "id1";
      col = Field_o_asset.empty
    }) (L.Cons ({
      id = "id2";
      col = Field_o_asset.empty
    }) (L.Nil))));
    _my_asset_assets_added = My_asset.empty;
    _my_asset_assets_removed = My_asset.empty;
    _ops = L.Nil;
    _balance = 0;
    _transferred = 0;
    _caller = "";
    _source = "";
    _now = 0;
    _chainid = 0;
    _selfaddress = "";
    _entry = None;
    _tr = L.Nil 
  }
  
  let function _cp_storage (_s_storage : _storage) : _storage
  ensures {
    [@expl:cp_1]
    result = _s_storage  
  }
  =  {
       _o_asset_assets = _s_storage._o_asset_assets;
       _o_asset_assets_added = _s_storage._o_asset_assets_added;
       _o_asset_assets_removed = _s_storage._o_asset_assets_removed;
       _my_asset_assets = _s_storage._my_asset_assets;
       _my_asset_assets_added = _s_storage._my_asset_assets_added;
       _my_asset_assets_removed = _s_storage._my_asset_assets_removed;
       _ops = _s_storage._ops;
       _balance = _s_storage._balance;
       _transferred = _s_storage._transferred;
       _caller = _s_storage._caller;
       _source = _s_storage._source;
       _now = _s_storage._now;
       _chainid = _s_storage._chainid;
       _selfaddress = _s_storage._selfaddress;
       _entry = _s_storage._entry;
       _tr = _s_storage._tr
     }
  
  val ref _s : _storage
end
module Effect_method_asset_removeif_partition
  use archetype.Lib
  
  use list.List as L
  
  use Effect_method_asset_removeif_partition_storage
  
  let exec () : unit
  raises { NotFound }
  requires {
    [@expl:entry_require]
    _s._entry = (Some EExec) 
  }
  requires {
   [@expl:empty_trace]
   _s._tr = L.Nil  
  }
  =  let _s_init = _cp_storage _s in
     (match My_asset.get "id0" _s._my_asset_assets with
      | Some _a -> _s._o_asset_assets <- O_asset.removeif_in_field_and_pred removeif_o_asset_0 _a.col _s._o_asset_assets;
                   _s._my_asset_assets <- Aggregate_col.removeif "id0" removeif_o_asset_0 _s._o_asset_assets _s._my_asset_assets
      | _ -> _s <- _cp_storage _s_init;
             raise NotFound 
      end;
      _s._tr <- L.Cons (Tr.TrUpdate_ FCol) _s._tr;
      _s._tr <- L.Cons (Tr.TrRm_ AO_asset) _s._tr)
end

