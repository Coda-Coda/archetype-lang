model governance

role[%transferable] chairperson

(* vote start *)
value[%mutable chairperson (instate Created)] date startDate

(* vote deadline *)
value[%mutable chairperson (instate Created)] date deadline

assert (startdate < deadline)

asset voter as role identified by address = {
  address : address;
  hasVoted : boolean;
}

asset ballot identified by val = {
  val   : string;
  nbvotes : uint;
}

asset winner = {
  val : string;
}

(* state machine *)
states
 | Created initial
 | Voting
 | Buried

transaction register = {
   args = {
     voter : address;
   }
   called by   chairperson;
   condition : instate Created;
   action    : voter.add {address := voter; hasVoted := false;};
}

transition start from Created to Vote = {
   condition : after startDate;
}

transaction vote = {
   args = {
     val : string;
   }
   called by voter;
   condition : instate Voting
               and (voter.get (Caller.address)).hasVoted = false;

   action    : (voter.get (Caller.address)).hasVoted := true,
               ballot.update val { nbvotes += 1; } { nbvotes := 0; };
}

transition bury from Voting to Buried = {
   condition : after deadline;
   action    : let nbvotesMax = ballot.max(nbvotes) in
               for (b in ballot)  {
                 if (b.nbvotes = nbvotesMax) {
                    winner.add { val := b.val; }
                 }
               };
}

assert (voter.when(voter.hasVoted = true).count = ballot.sum(nbvotes))

assert ((instate Create) or (instate Voting) -> is_empty winner)

assert (forall w : winner,
          forall b : ballot,
             b.nbvotes <= ballot.get(w.val).nbvotes)
