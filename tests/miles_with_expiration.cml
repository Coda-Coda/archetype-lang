model miles_with_expiration

role[%transferable] admin

(* id is a string because it is generated off-chain *)
asset mile identified by id sorted by expiration = {
   id         : string;
   amount     : uint;
   expiration : date;
} with { amount > 0 }

(* a partition ensures there is no direct access to mile collection *)
asset owner as role identified by addr = {
   addr  : address;
   miles : mile partition; (* injective (owner x mile) *)
}

transaction add = {
   args = {
     owner       : address;
     newmile     : mile;
   }
   called by admin;
   action    :
       owner.addifnotexist owner { miles := empty; },
       (* transaction must fail if mile already exists *)
       (owner.get owner).miles.add newmile;
}


transaction consume = {
  args = {
     owner : address;
     val : uint;
  }
  called by admin;

  condition :
     (owner.get owner).miles.when(mile.expiration > now).sum(amount)
           >= val;

  ensure : forall m : removed mile,
             mem m (before (owner.miles)) and m.expiration >= now;

  ensure : let o = owner.get owner in
           before o.miles.sum(amount) = (o.miles.sum(amount)) + val;

  ensure : is_empty added.mile;

  ensure : idem (mile.project(not mile.amount));

  ensure : idem (owner.when(owner.owner <> owner).miles);

  ensure : forall m : removed mile,
             forall o : fixed mile,
                m.expiration <= o.expiration;

  action :
     let remainder = val in
     let o = owner.get owner in
     for (m in o.miles.when(expiration >= now))
     (* remainder has a decreasing upper bound *)
     invariant (0 <= remainder and remainder <= to_iter.sum(amount))
     (* removed miles *)
     invariant (subset (removed miles) (o.miles.when(expiration >= now)))
     (* right amount consumed *)
     invariant (before miles.sum(amount) = miles.sum(amount) + nbmiles - remainder)
     (
          if (m.amount > remainder)
          then (
             m.amount  -= remainder,
             remainder := 0,
             break
          )
          else (
             if (m.amount = remainder)
             then (
                o.miles.remove m,
                remainder := 0,
                break
             )
             else (
                remainder -= m.amount,
                o.miles.remove m
             )
          )
     ),
     assert (remainder = 0);
}

(* this ensures that any mile was added with the ‘add’ transaction *)
assert (mile = Collection.fold (fun u o => union u o.miles) void owner)

transaction clear_expired = {
  called by admin;

  ensure : forall m : removed mile, m.expiration < now;

  ensure : is_empty (added mile);

  ensure : idem mile;

  action : mile.removeif (expiration < now());
}
