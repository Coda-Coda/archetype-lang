archetype miles_with_expiration

variable[%transferable%] admin role = @tz1aazS5ms5cbGkb6FN1wvWmN7yrMTTcr6wB

(* id is a string because it is generated off-chain *)
asset mile identified by id sorted by expiration = {
   id         : string;
   amount     : uint;
   expiration : date;
} with {
  m1 : amount > 0
}

(* a partition ensures there is no direct access to mile collection *)
asset owner identified by addr = {
  addr  : role;
  miles : mile partition; (* injective (owner x mile) *)
}

action add (ow : address) (newmile : mile) = {
   called by admin

   require {
     c1 : newmile.amount > 0
   }

   effect {
     if owner.contains ow then
      (owner.get ow).miles.add newmile
     else
      owner.add { addr = ow; miles = [newmile] }
   }
}

action consume (a : address) (quantity : uint) = {

  verification {
    assert p1 at zero_remainder = {
      remainder = 0
      invariants for loop {
        0 <= remainder <= to_iter.sum(amount)
      }
    }

    specification p2 = {
      mile.sum(the.amount) = before mile.sum(the.amount) - quantity
      invariants for loop {
        subset (removed miles) (ow.miles.select(expiration >= now))
      }
    }

    specification p3 = {
      forall m in removed mile, m.expiration >= now
      invariants for loop {
        before mile.sum(amount) = mile.sum(amount) + quantity - remainder
      }
    }

    specification p4 = {
      is_empty (added mile)
      invariants for loop {
        is_empty (added mile)
      }
    }
  }

  called by admin

  effect {
     let ow = owner.get a in
     let by_expiration = ow.miles.select(the.expiration > now) in (
       require (by_expiration.sum(the.amount) >= quantity);
       let remainder = quantity in
       loop : for (m in by_expiration) (
         if remainder > 0
         then (
           if m.amount > remainder
           then (
             remainder := 0;  (* this should be after instruction below
                                 this is to demonstrate verification
                                 capacity to not verify contract in this
                                 state *)
             mile.update m.id { amount  -= remainder }
           )
           else if m.amount = remainder
           then (
             remainder := 0;
             ow.miles.remove m.id
           ) else (
             remainder -= m.amount;
             ow.miles.remove m.id
           )
         );
       label zero_remainder)
     )
  }
}

verification {
  (* this ensures that any mile was added with the ‘add’ action *)
  specification g1 = {
    [_[ anyaction may be performed only by role admin]_]
  }

  specification g2 = {
    [_[ (remove mile) may be performed only by action [consume or clear_expired] ]_]
  }

  specification g3 = {
    not ( [_[ (add mile) may be performed only by action consume]_] )
  }
}

action clear_expired = {
  verification {
    specification s3 = {
      forall m in removed mile, m.expiration < now
    }
  }

  called by admin

  effect {
    for (o in owner) (
      o.miles.removeif (the.expiration < now)
    )
  }
}
