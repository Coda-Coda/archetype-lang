archetype fa12

constant totalsupply : nat = 10_000_000

asset allowance identified by addr_owner addr_spender to big_map {
  addr_owner       : address;
  addr_spender     : address;
  amount           : nat;
}

asset ledger identified by holder to big_map {
  holder     : address;
  tokens     : nat = 0;
} initialized by {
  { holder = caller; tokens = totalsupply }
}

entry %transfer (from_ : address, to_ : address, value : nat) {
  require {
    r1 otherwise "NotEnoughBalance" : ledger[from_].tokens >= value;
  }
  effect {
    if caller <> from_ then (
      var current = allowance[(from_, caller)].amount;
      dofailif(current < value, ("NotEnoughAllowance", ((value, current))));
      allowance.update((from_, caller), { amount -=  value });
    );
    ledger.update(from_, { tokens -= value });
    ledger.addupdate(to_, { tokens += value });
  }
}

entry approve(spender : address, value : nat) {
  var k = (caller, spender);
  if allowance.contains(k) then (
    var previous = allowance[k].amount;
    dofailif(previous > 0 and value > 0, (("UnsafeAllowanceChange", previous)));
  );
  allowance.addupdate( k, { amount = value });
}

entry getAllowance (owner : address, spender : address, cb : entrysig<nat>) {
  transfer 0tz to entry cb(allowance[(owner, spender)].amount);
}

entry getBalance (owner : address, cb : entrysig<nat>) {
  transfer 0tz to entry cb(ledger[owner].tokens);
}

entry getTotalSupply (cb : entrysig<nat>) {
  transfer 0tz to entry cb(totalsupply);
}

///////////////////////////////////////////////////////////////////////////////
// SPECIFICATION
///////////////////////////////////////////////////////////////////////////////

specification {
  s1: ledger.sum(tokens) = totalsupply;
}

specification entry %transfer (from_ : address, to_ : address, value : nat) {
  fails {
    f0 with (s : string) :
      s = "NotEnoughBalance" and
      let some after_from = ledger[from_] in
        after_from.tokens < value
      otherwise true;
    f1 with (v : string * (nat * nat)) :
      v[0] = "NotEnoughAllowance" and
      caller <> from_ and
      let some after_from_caller = allowance[(from_,caller)] in
        after_from_caller.amount < value and
        v[1][0] = value and
        v[1][1] = after_from_caller.amount
      otherwise true;
  }
  // LEDGER ASSET
  postcondition p1 { // effect on from_ nbtokens
    let some before_from = before.ledger[from_] in
      let some after_from = ledger[from_] in
        after_from.tokens = before_from.tokens - value
      otherwise true
    otherwise true
  }
  postcondition p2 { // effect on to_ nbtokens
    let some after_to = ledger[to_] in
      let some before_to = before.ledger[to_] in
        after_to.tokens = before_to.tokens + value
      otherwise
        after_to.tokens = value
    otherwise true
  }
  postcondition p3 { // other ledger assets are unchanged
    forall tokenholder in ledger,
      tokenholder.holder <> from_ ->
      tokenholder.holder <> to_ ->
      let some before_th = before.ledger[tokenholder.holder] in
        tokenholder = before_th
      otherwise true
  }
  postcondition p4 { // no ledger asset is removed
    removed.ledger.isempty()
  }
  postcondition p5 { // added ledger asset may be to_
    forall tokenholder in added.ledger,
      tokenholder.holder = to_
  }
  postcondition p6 { // number of added asset is one
    let some before_to = before.ledger[to_] in
      true
    otherwise
      ledger.count() = before.ledger.count() + 1
  }
  // ALLOWANCE ASSET
  postcondition p7 { // effect on allowance
    caller <> from_ ->
    let some before_from_caller = before.allowance[(from_,caller)] in
      let some after_from_caller = allowance[(from_,caller)] in
        before_from_caller.amount > value ->
        after_from_caller.amount = before_from_caller.amount - value
      otherwise true
    otherwise true
  }
  postcondition p8 { // other allowance assets are unchanged
    forall a in allowance,
      a.addr_owner <> from_ and a.addr_spender <> caller ->
      let some before_a = before.allowance[(from_,caller)] in
        a = before_a
      otherwise true
  }
  postcondition p9 { // no allowance is added or removed
    removed.ledger.isempty() and added.ledger.isempty()
  }
}
