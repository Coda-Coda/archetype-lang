theory Types

  use int.Int
  use mach.int.UInt32

  (* default type mapping *)
  type key     = int
  type role    = int
  type address = int
  type uint    = uint32
  type tez     = int
  type date    = int
  type string  = int

  constant max_uint : int = UInt32.max_uint32

  exception Break
  exception NotFound

end

theory Contract

  use Types
  use int.Int
  use mach.int.UInt32
  use list.List
  use list.Append
  use set.Fset
  use set.FsetNth
  use set.FsetSum
  use array.Array

  (* currency transfer during transaction *)
  type transfer = {
     destination : address;
     amount      : tez;
  }

  type transfers = list transfer

  let empty : transfers = Nil

  type env = {
     mutable balance_ : tez;
     (* transaction env *)
     transferred_     : tez;
     caller_          : address;
     now_             : date;
  }

  let empty_env () : env = { balance_ = 0; transferred_ = 0; caller_ = 0; now_ = 0 }

  let function balance (e: env) : tez = e.balance_

  let function transferred (e : env) : tez = e.transferred_

  let function caller (e : env) : address = e.caller_

  let function now (e : env) : date = e.now_

  let update_balance (e : env)
    requires { transferred e + balance e <= max_uint }
    ensures  { balance e = old (balance e) + (transferred e)}
  =
    let sum = e.balance_ + e.transferred_ in
    e.balance_ <- sum

  let exec_transfer (e : env) (a : address) (c : tez) (ops : transfers) : transfers
    requires { c <= balance e }
    ensures  { old (balance e) = (balance e) + c }
  =
    e.balance_ <- e.balance_ - c;
    let transfer = { destination = a; amount = c } in
    ops ++ (Cons transfer Nil)

end

(* non ghost map *)
module Map

  (* import non ghost equality on integer *)
  use int.Int
  use Types

  type map 'value = key -> 'value

  let function get (f: map 'value) (x: key) : 'value = f x

  let function set (f: map 'value) (x: key) (v: 'value) : map 'value =
    fun (y : key) -> if y = x then v else f y

  let function const (v : 'value) : map 'value = fun _ -> v

end

(* Set with : mem length add remove diff nth
  implemented with list type
 *)
theory Asset

  use list.List
  use list.Length
  use list.Elements
  use list.Append
  use list.Nth
  use list.Mem
  use set.Fset
  use option.Option
  use int.Int

  use Types
  use Contract
  use Map

  type acol = list key

  let rec predicate mem (k : key) (a : acol) : bool =
    match a with
    | Cons e tl ->
      if e = k
      then true
      else mem k tl
    | Nil -> false
    end

  let function length (c : list 'a) = length c

  let function add (a : 'a) (c : list 'a) = c ++ (Cons a Nil)

  let addifnotexist (a : key) (c : acol) : acol =
  if mem a c
  then c
  else c ++ (Cons a Nil)

  let rec function remove (a : 'a)
                          (eq : 'a -> 'a -> bool)
                          (c : list 'a) : list 'a
  =
     match c with
     | Nil -> Nil
     | Cons e tl ->
       if eq e a
       then remove a eq tl
       else Cons e (remove a eq tl)
     end

  let ghost function diff (c1 c2 : list 'a)
  = Fset.diff (elements c1) (elements c2)

  let ghost function subset (c1 c2 : list 'a)
  = Fset.subset (elements c1) (elements c2)

  predicate is_empty (c : acol) = forall m : key. not (mem m c)

  let function nth (i : key) (c : acol) : option key = nth i c

  (* should not be ghost *)
  let ghost function sum (c : list 'a) (f : 'a -> key)
  = FsetSum.sum (elements c) f

  (* not really used *)
  let rec fold (f : {'a} -> 'k -> 'a)
               (acc : {'a})
               (l : list 'k) : 'a
  variant { l } =
  match l with
  | Cons e tl -> fold f (f acc e) tl
  | Nil -> acc
  end

  axiom split_mem : forall l : list 'a, x y : 'a.
   Mem.mem x l \/ x = y <-> Mem.mem x (l ++ (Cons y Nil))

end

theory Sum

  (* import comparison operators on key *)
  use int.Int
  use Types
  use Asset

  type storage

  function f storage key : int

  function sum acol int int : int

  lemma Sum_def_empty :
    forall c: acol, i j : int.
    j <= i -> sum c i j = 0

  lemma Sum_def_non_empty :
    forall s : storage, c: acol, i j : int.
    i < j -> sum c i j = f s i + sum c (i+1) j

  lemma Sum_right_extension:
    forall s : storage, c : acol, i j : int.
    i < j -> sum c i j = sum c i (j-1) + f s (j-1)

  lemma Sum_transitivity :
    forall c : acol, i k j : int. i <= k <= j ->
    sum c i j = sum c i k + sum c k j

  lemma Sum_eq :
    forall s : storage, c1 c2 : acol, i j : int.
    (forall k : int. i <= k < j -> mem k c1 /\ mem k c2) -> sum c1 i j = sum c2 i j

end

(*
theory When

  use Types
  use Contract
  use Asset
  (* import Nil constant *)
  use list.List

  type storage

  val function test env storage key : bool

  let rec function when (e : env) (s : storage) (c : acol) : acol
  ensures { forall e : env, s : storage, a : key.
                mem a result <-> test e s a }
  ensures { subset result c }
  ensures { forall i j : int. i <> j -> not ((nth i result) = (nth j result)) }
  =
  match c with
  | Nil -> Nil
  | Cons a tl ->
    if test e s a
    then Cons a (when e s tl)
    else when e s tl
  end

end*)