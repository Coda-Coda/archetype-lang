module Test

  use int.Int

  type storage = {
    mutable       value   : int;
    ghost mutable counter : int;
  } invariant { counter <= 1 }
    by { value = 1; counter = 0 }

  (* should it be a lemma ? *)
  axiom init : forall s : storage. s.value > 0 -> s.counter = 0

  let only_once (s : storage) : unit
  =
   if s.value > 0
   then (
     s.value <- 0;
     ghost (s.counter <- s.counter +1))

end

(* this test adds a state variable *)
module Test2

  use int.Int

  type states = Open | Closed

  type storage = {
    mutable value : int;
            state : states;
    ghost mutable counter : int;
  } invariant { counter <= 1 }
    by { value = 10; state = Open; counter = 0 }

  let is_open s =
    match s.state with
    | Open -> true
    | _ -> false
    end

  let is_closed s =
    match s.state with
    | Closed -> true
    | _ -> false
    end

  let call_in_open (s : storage) =
  if is_open s
  then
   (s.value <- 10)

  axiom state_only_closed : forall s : storage.
        s.state = Closed  ->
        s.value > 0 ->
        s.counter = 0

  let only_once (s : storage)
  =
   if is_closed s
   then
     if s.value > 0
     then (
       s.value <- 0;
       ghost (s.counter <- s.counter +1)
     )

end