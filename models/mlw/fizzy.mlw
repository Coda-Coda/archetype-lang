theory Fizzy

  use cml3.Contract
  use cml3.Types
  use cml3.Map
  use cml3.Asset
  use int.Int
  use list.List
  use list.Append
  use list.List
  use option.Option
  use list.Mem

  (* TRACES ********************************************************************)

  type entry =
  | Addflightinsurance
  | Updatestatus
  | Manual

  (* asset type is built with asset key value *)
  type asset =
  | Insurance string
  | Flight string

  type field =
  | Limit
  | Premium
  | Indemnity
  | Stat
  | Product
  | Insurances

  type action =
  | Add
  | Rm
  | Get
  | Update field
  | Loop

  type trace = {
    entry : entry;
    asset : asset;
    action : action;
  }

  type traces = list trace

  let mk_trace (e : entry) (a : asset) (c : action) : traces = Cons ({
    entry = e;
    asset = a;
    action = c;
  }) Nil

  predicate performed_only_by  (tr : traces) (e : env)  (a:action) (r:address) =
  forall x:trace. action x = a -> Mem.mem x tr -> caller e = r

  predicate may_perform (tr : traces) (tx1 tx2:option entry) (a:action) =
  forall x:trace. Mem.mem x tr -> tx1 = tx2 -> action x = a

  predicate is_empty (l : list 'a) = l = Nil

  (* ************************************************************************ *)

  type status =
  | Created
  | Before
  | After
  | Cancelled
  | FlightCancelled
  | Redirected
  | Diverted

 type storage = {
   mutable owner        : address;
   (* internal insruance key generator *)
   mutable ikey         : int;
   (* asset key lists  *)
   mutable insurances   : list string;
   mutable flights      : list string;
   (* insurance fields *)
   mutable limit        : map date;
   mutable premium      : map tez;
   mutable indemnity    : map tez;
   mutable stat         : map status;
   mutable productid    : map string;
   (* flight fields *)
   mutable finsurances  : map (list string);
   (* others *)
   mutable e            : env;
   mutable ops          : transfers;
   mutable tr           : traces;
   mutable ename        : option entry;
 }
   invariant { forall a:action. performed_only_by tr e a owner }
   invariant { forall tx:entry. ename = Some tx -> is_empty ops }
   invariant { may_perform tr ename (Some Updatestatus) (Update Stat) }
   invariant { may_perform tr ename (Some Manual) (Update Stat) }
   by { owner = 0; ikey = 0; insurances = Nil; flights = Nil;
        limit = const 0; premium = const 0; indemnity = const 0;
        stat = const Created; productid = const 0; finsurances = const Nil;
        e = empty_env (); ops = Nil; tr = Nil; ename = None }
(*   invariant { forall x:trace. Mem.mem x tr ->
               action x = Update Stat /\ ename = Updatestatus }*)

 let all_entries (s   : storage)
                 (fi  : string)
                 (li  : date)
                 (pre : tez)
                 (ind : tez)
                 (pro : string)
                 (fk      : string)
                 (arrival : string)
                 (st  : status): unit
 raises { NotFound }
 =
 match s.ename with
 | Some Addflightinsurance ->
   if caller s.e = s.owner
   then (
     let f = fi in
     s.flights <- addifnotexist fi s.flights;
     (* add insurance *)
     s.insurances <- add s.ikey s.insurances;
     s.limit      <- set s.limit f li;
     s.premium    <- set s.premium f pre;
     s.indemnity  <- set s.indemnity f ind;
     s.stat       <- set s.stat f Created;
     s.productid  <- set s.productid f pro;
     (* update finsurance *)
     s.finsurances <- set s.finsurances fi (add s.ikey (get s.finsurances f));
     s.ikey        <- s.ikey + 1;
     s.tr          <- s.tr ++ mk_trace Addflightinsurance (Insurance (s.ikey-1)) Add;
     s.tr          <- s.tr ++ mk_trace Addflightinsurance (Flight f) Add)
   else ()
  | Some Updatestatus ->
   if caller s.e = s.owner
   then
     let l = get s.finsurances fk in
     for i=0 to (length l) - 1 do
     invariant { may_perform s.tr s.ename (Some Updatestatus) (Update Stat) }
     invariant { may_perform s.tr s.ename (Some Manual) (Update Stat) }
       let k = nth i l in
       match get s.stat k with
       | Created ->
         if arrival > get s.limit k
         then (
           s.stat <- set s.stat k After;
           s.tr   <- s.tr ++ mk_trace Updatestatus (Insurance k) (Update Stat)
         )
         else ()
       | _ -> ()
       end
     done
   else ()
 | Some Manual ->
   if caller s.e = s.owner
   then
     let l = get s.finsurances fk in
     for i=0 to (length l) - 1 do
     invariant { may_perform s.tr s.ename (Some Updatestatus) (Update Stat) }
     invariant { may_perform s.tr s.ename (Some Manual) (Update Stat) }
       let k = nth i l in
       match get s.stat k with
       | Created ->
         s.stat <- set s.stat k st;
         s.tr   <- s.tr ++ mk_trace Updatestatus (Insurance k) (Update Stat)
       | _ -> ()
       end
     done
   else ()
 | None -> ()
 end

(*
 let addflightinsurance (s   : storage)
                        (fi  : string)
                        (li  : date)
                        (pre : tez)
                        (ind : tez)
                        (pro : string) : unit
   =
   s.ename <- Addflightinsurance;
   if caller s.e = s.owner
   then (
     let f = fi in
     s.flights <- addifnotexist fi s.flights;
     (* add insurance *)
     s.insurances <- add s.ikey s.insurances;
     s.limit      <- set s.limit f li;
     s.premium    <- set s.premium f pre;
     s.indemnity  <- set s.indemnity f ind;
     s.stat       <- set s.stat f Created;
     s.productid  <- set s.productid f pro;
     (* update finsurance *)
     s.finsurances <- set s.finsurances fi (add s.ikey (get s.finsurances f));
     s.ikey        <- s.ikey + 1;
     s.tr          <- s.tr ++ mk_trace Addflightinsurance (Insurance (s.ikey-1)) Add;
     s.tr          <- s.tr ++ mk_trace Addflightinsurance (Flight f) Add
     )
   else ()

 let updatestatus (s       : storage)
                  (fk      : string)
                  (arrival : string) : unit
 raises { NotFound }
 =
 s.ename <- Updatestatus;
 if caller s.e = s.owner
 then
   let l = get s.finsurances fk in
   for i=0 to (length l) - 1 do
     let k = nth i l in
     match get s.stat k with
     | Created ->
       if arrival > get s.limit k
       then (
         s.stat <- set s.stat k After;
         s.tr   <- s.tr ++ mk_trace Updatestatus (Insurance k) (Update Stat)
       )
       else ()
     | _ -> ()
     end
   done
 else ()

 let manual       (s   : storage)
                  (fk  : string)
                  (st  : status) : unit
 raises { NotFound }
 =
 s.ename <- Manual;
 if caller s.e = s.owner
 then
   let l = get s.finsurances fk in
   for i=0 to (length l) - 1 do
   invariant { may_perform s.tr s.ename Updatestatus (Update Stat) }
   invariant { may_perform s.tr s.ename Manual (Update Stat) }
     let k = nth i l in
     match get s.stat k with
     | Created ->
       s.stat <- set s.stat k st;
       s.tr   <- s.tr ++ mk_trace Updatestatus (Insurance k) (Update Stat)
     | _ -> ()
     end
   done
 else ()
*)
end