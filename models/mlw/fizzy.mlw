theory Fizzy

  use cml3.Contract
  use cml3.Types
  use cml3.Map
  use cml3.Asset
  use int.Int
  use list.List
  use list.Append
  use list.List
  use option.Option
  use list.Mem

  (* TRACES ********************************************************************)

  type entry =
  | Addflightinsurance
  | Updatestatus
  | Manual

  (* asset type is built with asset key value *)
  type asset =
  | Insurance string
  | Flight string

  type field =
  | Limit
  | Premium
  | Indemnity
  | Stat
  | Product
  | Insurances

  type action =
  | Add
  | Rm
  | Get
  | Update field
  | Loop

  type trace = {
    entry : entry;
    asset : asset;
    action : action;
  }

  type traces = list trace

  let mk_trace (e : entry) (a : asset) (c : action) : traces = Cons ({
    entry = e;
    asset = a;
    action = c;
  }) Nil

  predicate action_performed_only_by (e : env) (x : trace) (a : action) (p : address) =
            action x = a /\ caller e = p

  predicate is_void (l : list 'a) = l = Nil

  (* ************************************************************************ *)

  type status =
  | Created
  | Before
  | After
  | Cancelled
  | FlightCancelled
  | Redirected
  | Diverted

 type storage = {
           owner        : address;
   (* internal insruance key generator *)
   ikey         : int;
   (* asset key lists  *)
   insurances   : list string;
   flights      : list string;
   (* insurance fields *)
   limit        : map date;
   premium      : map tez;
   indemnity    : map tez;
   stat         : map status;
   productid    : map string;
   (* flight fields *)
   finsurances  : map (list string);
 } (*with { owner = 0; ikey = 0; insurances = Nil; flights = Nil; }*)

 let addflightinsurance  (e   : env)
                         (s   : storage)
                         (fi  : string)
                         (li  : date)
                         (pre : tez)
                         (ind : tez)
                         (pro : string) : (traces, transfers, storage)
   ensures { let tr,_,_ = result in
             forall x : trace. Mem.mem x tr ->
             exists a:action. action_performed_only_by e x a s.owner  }
   ensures { let _,ops,_ = result in is_void ops  }
   =
   let tr = Nil in
   let ops = Nil in
   if caller e = s.owner
   then
     let f = fi in
     let s = { s with
       flights = addifnotexist fi s.flights;
       (* add insurance *)
       insurances = add s.ikey s.insurances;
       limit      = set s.limit f li;
       premium    = set s.premium f pre;
       indemnity  = set s.indemnity f ind;
       stat       = set s.stat f Created;
       productid  = set s.productid f pro;
       (* update finsurance *)
       finsurances = set s.finsurances fi (add s.ikey (get s.finsurances f));
       ikey        = s.ikey + 1
    } in
    let tr = tr ++ mk_trace Addflightinsurance (Insurance (s.ikey-1)) Add in
    let tr = tr ++ mk_trace Addflightinsurance (Flight f) Add in
    (tr, ops, s)
  else (tr, Nil, s)

  let rec updatestatus_loop1 (e : env) (arrival: date)
                            (acc : (traces, transfers, storage))
                            (l : list string)
   variant { l }
   requires { let _, _, s = acc in caller e = s.owner }
   requires { let _, ops, _ = acc in is_void ops }
   requires { let tr,_,s = acc in
              forall x : trace. Mem.mem x tr ->
              exists a:action. action_performed_only_by e x a s.owner }
   ensures  { let _, ops, _ = result in is_void ops }
   ensures  { let tr, _, s  = result in
              forall x : trace. Mem.mem x tr ->
              exists a:action. action_performed_only_by e x a s.owner }
   =
   match l with
   | Cons k tl ->
     let acc =
       (let (tr, ops, s) = acc in
        match get s.stat k with
        | Created ->
          let (tr, ops, s) = acc in
          if arrival > get s.limit k
          then
            let s = { s with
              stat = set s.stat k After
            } in
            let tr = tr ++ mk_trace Updatestatus (Insurance k) (Update Stat) in
            (tr, ops, s)
          else (tr, ops, s)
        | _ -> (tr, ops, s)
        end) in
     updatestatus_loop1 e arrival acc tl
   | Nil -> acc
   end

  let updatestatus (e: {env})
                   (s: {storage})
                   (fk : string)
                   (arrival : date) : (traces, transfers, storage)
   ensures {  let tr, _, s  = result in
              forall x : trace. Mem.mem x tr ->
              exists a:action. action_performed_only_by e x a s.owner }
   ensures { let _, ops, _ = result in is_void ops  }
   =
   let tr = Nil in
   let ops = Nil in
   if caller e = s.owner
   then
     let (tr, ops, s) =
     updatestatus_loop1 e arrival (tr, ops, s) (get s.finsurances fk) in
     (tr, ops, s)
   else (tr, ops, s)

 let rec manual_loop1 (e:env) (st : status)
                  (acc : (traces, transfers, storage))
                  (l : list string) : (traces, transfers, storage)
   variant  { l }
   requires { let _, _, s = acc in caller e = s.owner }
   requires { let tr,_,s = acc in
              forall x : trace. Mem.mem x tr ->
              exists a:action. action_performed_only_by e x a s.owner }
   requires { let _,ops,_ = acc in is_void ops }
   ensures  { let _,ops,_ = result in is_void ops }
   ensures { let tr,_,s = result in
             forall x : trace. Mem.mem x tr ->
             exists a:action. action_performed_only_by e x a s.owner }
   =
   match l with
   | Cons k tl ->
       let acc =
         (let (tr, ops, s) = acc in
          match get s.stat k with
          | Created ->
            let s = { s with
              stat = set s.stat k st;
            } in
            let tr = tr ++ mk_trace Manual (Insurance k) (Update Stat) in
            (tr, ops, s)
          | _ -> (tr, ops, s)
         end) in
     manual_loop1 e st acc tl
   | Nil -> acc
   end

 let manual (e  : {env})
            (s  : {storage})
            (fk : string)
            (st : status) : (traces, transfers, storage)
   ensures { let tr,_,_ = result in
             forall x : trace. Mem.mem x tr ->
             exists a:action. action_performed_only_by e x a s.owner }
   ensures { let _,ops,_ = result in is_void ops }
   =
   let ops = Nil in
   let tr = Nil in
   if caller e = s.owner
   then
     let (tr, ops, s) = manual_loop1 e st (tr, ops, s) (get s.finsurances fk) in
     (tr, ops, s)
   else (tr, ops, s)

end