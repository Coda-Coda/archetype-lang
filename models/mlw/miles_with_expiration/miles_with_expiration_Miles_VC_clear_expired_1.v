(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.
Require map.Map.
Require list.List.
Require list.Length.
Require list.Mem.
Require list.Nth.
Require option.Option.
Require list.Append.

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | mk_ref : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Arguments mk_ref {a}.

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:ref a) : a :=
  match v with
  | mk_ref x => x
  end.

Axiom uint32 : Type.
Parameter uint32_WhyType : WhyType uint32.
Existing Instance uint32_WhyType.

Parameter uint32'int: uint32 -> Z.

Axiom uint32'axiom :
  forall (i:uint32),
  (0%Z <= (uint32'int i))%Z /\ ((uint32'int i) <= 4294967295%Z)%Z.

(* Why3 assumption *)
Definition in_bounds (n:Z) : Prop := (0%Z <= n)%Z /\ (n <= 4294967295%Z)%Z.

Axiom to_int_in_bounds : forall (n:uint32), in_bounds (uint32'int n).

Axiom extensionality :
  forall (x:uint32) (y:uint32), ((uint32'int x) = (uint32'int y)) -> (x = y).

Parameter zero_unsigned: uint32.

Axiom zero_unsigned_is_zero : ((uint32'int zero_unsigned) = 0%Z).

(* Why3 assumption *)
Definition key := Z.

(* Why3 assumption *)
Definition role := Z.

(* Why3 assumption *)
Definition address := Z.

(* Why3 assumption *)
Definition uint := uint32.

(* Why3 assumption *)
Definition tez := Z.

(* Why3 assumption *)
Definition date := Z.

(* Why3 assumption *)
Definition string := Z.

Axiom array : forall (a:Type), Type.
Parameter array_WhyType :
  forall (a:Type) {a_WT:WhyType a}, WhyType (array a).
Existing Instance array_WhyType.

Parameter elts: forall {a:Type} {a_WT:WhyType a}, (array a) -> Z -> a.

Parameter length: forall {a:Type} {a_WT:WhyType a}, (array a) -> Z.

Axiom array'invariant :
  forall {a:Type} {a_WT:WhyType a},
  forall (self:array a), (0%Z <= (length self))%Z.

(* Why3 assumption *)
Definition mixfix_lbrb {a:Type} {a_WT:WhyType a} (a1:array a) (i:Z) : a :=
  (elts a1) i.

Parameter mixfix_lblsmnrb:
  forall {a:Type} {a_WT:WhyType a}, (array a) -> Z -> a -> array a.

Axiom mixfix_lblsmnrb_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Z) (v:a),
  ((length (mixfix_lblsmnrb a1 i v)) = (length a1)).

Axiom mixfix_lblsmnrb_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Z) (v:a),
  ((elts (mixfix_lblsmnrb a1 i v)) = (map.Map.set (elts a1) i v)).

Parameter make: forall {a:Type} {a_WT:WhyType a}, Z -> a -> array a.

Axiom make_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (n:Z) (v:a), (0%Z <= n)%Z -> forall (i:Z),
  ((0%Z <= i)%Z /\ (i < n)%Z) -> ((mixfix_lbrb (make n v) i) = v).

Axiom make_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (n:Z) (v:a), (0%Z <= n)%Z -> ((length (make n v)) = n).

(* Why3 assumption *)
Inductive transfer :=
  | mk_transfer : Z -> Z -> transfer.
Axiom transfer_WhyType : WhyType transfer.
Existing Instance transfer_WhyType.

(* Why3 assumption *)
Definition amount (v:transfer) : Z :=
  match v with
  | mk_transfer x x1 => x1
  end.

(* Why3 assumption *)
Definition destination (v:transfer) : Z :=
  match v with
  | mk_transfer x x1 => x
  end.

(* Why3 assumption *)
Definition transfers := (list transfer).

(* Why3 assumption *)
Inductive env :=
  | mk_env : Z -> Z -> Z -> Z -> env.
Axiom env_WhyType : WhyType env.
Existing Instance env_WhyType.

(* Why3 assumption *)
Definition now_ (v:env) : Z := match v with
                               | mk_env x x1 x2 x3 => x3
                               end.

(* Why3 assumption *)
Definition caller_ (v:env) : Z := match v with
                                  | mk_env x x1 x2 x3 => x2
                                  end.

(* Why3 assumption *)
Definition transferred_ (v:env) : Z :=
  match v with
  | mk_env x x1 x2 x3 => x1
  end.

(* Why3 assumption *)
Definition balance_ (v:env) : Z := match v with
                                   | mk_env x x1 x2 x3 => x
                                   end.

(* Why3 assumption *)
Definition map (value:Type) := Z -> value.

Parameter set:
  forall {value:Type} {value_WT:WhyType value}, (Z -> value) -> Z -> value ->
  Z -> value.

Axiom set_def :
  forall {value:Type} {value_WT:WhyType value},
  forall (f:Z -> value) (x:Z) (v:value) (y:Z),
  ((y = x) -> (((set f x v) y) = v)) /\
  (~ (y = x) -> (((set f x v) y) = (f y))).

(* Why3 assumption *)
Definition const {value:Type} {value_WT:WhyType value} (v:value) : Z -> value :=
  fun (us:Z) => v.

Axiom set1 : forall (a:Type), Type.
Parameter set1_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (set1 a).
Existing Instance set1_WhyType.

Parameter mem: forall {a:Type} {a_WT:WhyType a}, a -> (set1 a) -> Prop.

Parameter infix_eqeq:
  forall {a:Type} {a_WT:WhyType a}, (set1 a) -> (set1 a) -> Prop.

Axiom infix_eqeq_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a), (infix_eqeq s1 s2) -> forall (x:a),
  (mem x s1) -> mem x s2.

Axiom infix_eqeq_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a), (infix_eqeq s1 s2) -> forall (x:a),
  (mem x s2) -> mem x s1.

Axiom infix_eqeq_spec2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a),
  (forall (x:a), (mem x s1) <-> (mem x s2)) -> infix_eqeq s1 s2.

Axiom extensionality1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a), (infix_eqeq s1 s2) -> (s1 = s2).

Parameter subset:
  forall {a:Type} {a_WT:WhyType a}, (set1 a) -> (set1 a) -> Prop.

Axiom subset_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a), (subset s1 s2) -> forall (x:a),
  (mem x s1) -> mem x s2.

Axiom subset_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a), (forall (x:a), (mem x s1) -> mem x s2) ->
  subset s1 s2.

Axiom subset_refl :
  forall {a:Type} {a_WT:WhyType a}, forall (s:set1 a), subset s s.

Axiom subset_trans :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a) (s3:set1 a), (subset s1 s2) ->
  (subset s2 s3) -> subset s1 s3.

Parameter is_empty: forall {a:Type} {a_WT:WhyType a}, (set1 a) -> Prop.

Axiom is_empty_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set1 a), (is_empty s) -> forall (x:a), ~ (mem x s).

Axiom is_empty_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set1 a), (forall (x:a), ~ (mem x s)) -> is_empty s.

Parameter empty: forall {a:Type} {a_WT:WhyType a}, set1 a.

Axiom empty_def :
  forall {a:Type} {a_WT:WhyType a}, is_empty (empty : set1 a).

Parameter add: forall {a:Type} {a_WT:WhyType a}, a -> (set1 a) -> set1 a.

Axiom add_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set1 a), forall (y:a), (mem y (add x s)) ->
  (y = x) \/ (mem y s).

Axiom add_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set1 a), forall (y:a), (y = x) -> mem y (add x s).

Axiom add_spec2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set1 a), forall (y:a), (mem y s) -> mem y (add x s).

Parameter remove: forall {a:Type} {a_WT:WhyType a}, a -> (set1 a) -> set1 a.

Axiom remove_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set1 a), forall (y:a), (mem y (remove x s)) -> ~ (y = x).

Axiom remove_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set1 a), forall (y:a), (mem y (remove x s)) -> mem y s.

Axiom remove_spec2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set1 a), forall (y:a), (~ (y = x) /\ (mem y s)) ->
  mem y (remove x s).

Axiom add_remove :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set1 a), (mem x s) -> ((add x (remove x s)) = s).

Axiom remove_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set1 a), ((remove x (add x s)) = (remove x s)).

Axiom subset_remove :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (s:set1 a), subset (remove x s) s.

Parameter union:
  forall {a:Type} {a_WT:WhyType a}, (set1 a) -> (set1 a) -> set1 a.

Axiom union_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a), forall (x:a), (mem x (union s1 s2)) ->
  (mem x s1) \/ (mem x s2).

Axiom union_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a), forall (x:a), (mem x s1) ->
  mem x (union s1 s2).

Axiom union_spec2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a), forall (x:a), (mem x s2) ->
  mem x (union s1 s2).

Parameter inter:
  forall {a:Type} {a_WT:WhyType a}, (set1 a) -> (set1 a) -> set1 a.

Axiom inter_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a), forall (x:a), (mem x (inter s1 s2)) ->
  mem x s1.

Axiom inter_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a), forall (x:a), (mem x (inter s1 s2)) ->
  mem x s2.

Axiom inter_spec2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a), forall (x:a), ((mem x s1) /\ (mem x s2)) ->
  mem x (inter s1 s2).

Parameter diff:
  forall {a:Type} {a_WT:WhyType a}, (set1 a) -> (set1 a) -> set1 a.

Axiom diff_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a), forall (x:a), (mem x (diff s1 s2)) ->
  mem x s1.

Axiom diff_spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a), forall (x:a), (mem x (diff s1 s2)) ->
  ~ (mem x s2).

Axiom diff_spec2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a), forall (x:a),
  ((mem x s1) /\ ~ (mem x s2)) -> mem x (diff s1 s2).

Axiom subset_diff :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a), subset (diff s1 s2) s1.

Parameter choose: forall {a:Type} {a_WT:WhyType a}, (set1 a) -> a.

Axiom choose_spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set1 a), ~ (is_empty s) -> mem (choose s) s.

Parameter cardinal: forall {a:Type} {a_WT:WhyType a}, (set1 a) -> Z.

Axiom cardinal_nonneg :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set1 a), (0%Z <= (cardinal s))%Z.

Axiom cardinal_empty :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set1 a), ((cardinal s) = 0%Z) -> is_empty s.

Axiom cardinal_empty1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set1 a), (is_empty s) -> ((cardinal s) = 0%Z).

Axiom cardinal_add :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a), forall (s:set1 a), ~ (mem x s) ->
  ((cardinal (add x s)) = (1%Z + (cardinal s))%Z).

Axiom cardinal_remove :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a), forall (s:set1 a), (mem x s) ->
  ((cardinal s) = (1%Z + (cardinal (remove x s)))%Z).

Axiom cardinal_subset :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a), (subset s1 s2) ->
  ((cardinal s1) <= (cardinal s2))%Z.

Axiom subset_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a), (subset s1 s2) ->
  ((cardinal s1) = (cardinal s2)) -> infix_eqeq s1 s2.

Axiom cardinal1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set1 a), ((cardinal s) = 1%Z) -> forall (x:a), (mem x s) ->
  (x = (choose s)).

(* Why3 assumption *)
Fixpoint elements {a:Type} {a_WT:WhyType a}
  (l:(list a)) {struct l}: set1 a :=
  match l with
  | Init.Datatypes.nil => empty : set1 a
  | (Init.Datatypes.cons x r) => add x (elements r)
  end.

Axiom elements_mem :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (l:(list a)), (list.Mem.mem x l) -> mem x (elements l).

Axiom elements_mem1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (l:(list a)), (mem x (elements l)) -> list.Mem.mem x l.

(* Why3 assumption *)
Definition acol := (list Z).

(* Why3 assumption *)
Fixpoint mem1 (k:Z) (a:(list Z)) {struct a}: Prop :=
  match a with
  | (Init.Datatypes.cons e tl) => (e = k) \/ (mem1 k tl)
  | Init.Datatypes.nil => False
  end.

(* Why3 assumption *)
Definition add1 (a:Z) (c:(list Z)) : (list Z) :=
  (Init.Datatypes.app c (Init.Datatypes.cons a Init.Datatypes.nil)).

Axiom add_spec3 :
  forall (a:Z) (c:(list Z)), forall (x:Z), (mem1 a (add1 a c)) ->
  (mem1 x c) \/ (x = a).

Axiom add_spec4 :
  forall (a:Z) (c:(list Z)), forall (x:Z), (mem1 x c) -> mem1 a (add1 a c).

Axiom add_spec5 :
  forall (a:Z) (c:(list Z)), forall (x:Z), (x = a) -> mem1 a (add1 a c).

Parameter remove1: Z -> (list Z) -> (list Z).

Axiom remove_def :
  forall (a:Z) (c:(list Z)), (mem1 a c) -> (c = Init.Datatypes.nil) ->
  ((remove1 a c) = Init.Datatypes.nil).

Axiom remove_def1 :
  forall (a:Z) (c:(list Z)), (mem1 a c) -> forall (x:Z) (x1:(list Z)),
  (c = (Init.Datatypes.cons x x1)) -> (x = a) ->
  ((remove1 a c) = (remove1 a x1)).

Axiom remove_def2 :
  forall (a:Z) (c:(list Z)), (mem1 a c) -> forall (x:Z) (x1:(list Z)),
  (c = (Init.Datatypes.cons x x1)) -> ~ (x = a) ->
  ((remove1 a c) = (Init.Datatypes.cons x (remove1 a x1))).

Axiom remove_spec3 :
  forall (a:Z) (c:(list Z)), (mem1 a c) -> forall (k:Z),
  (mem1 a (remove1 a c)) -> mem1 k c.

Axiom remove_spec4 :
  forall (a:Z) (c:(list Z)), (mem1 a c) -> forall (k:Z),
  (mem1 a (remove1 a c)) -> ~ (k = a).

Axiom remove_spec5 :
  forall (a:Z) (c:(list Z)), (mem1 a c) -> forall (k:Z),
  ((mem1 k c) /\ ~ (k = a)) -> mem1 a (remove1 a c).

Parameter diff1: (list Z) -> (list Z) -> (list Z).

Axiom diff_def :
  forall (c1:(list Z)) (c2:(list Z)),
  match c1 with
  | Init.Datatypes.nil => ((diff1 c1 c2) = Init.Datatypes.nil)
  | (Init.Datatypes.cons h tl) =>
      ((mem1 h c2) -> ((diff1 c1 c2) = (diff1 tl c2))) /\
      (~ (mem1 h c2) ->
       ((diff1 c1 c2) = (Init.Datatypes.cons h (diff1 tl c2))))
  end.

Axiom diff_spec3 :
  forall (c1:(list Z)) (c2:(list Z)), forall (x:Z), (mem1 x (diff1 c1 c2)) ->
  mem1 x c1.

Axiom diff_spec4 :
  forall (c1:(list Z)) (c2:(list Z)), forall (x:Z), (mem1 x (diff1 c1 c2)) ->
  ~ (mem1 x c2).

Axiom diff_spec5 :
  forall (c1:(list Z)) (c2:(list Z)), forall (x:Z),
  ((mem1 x c1) /\ ~ (mem1 x c2)) -> mem1 x (diff1 c1 c2).

(* Why3 assumption *)
Definition is_empty1 (c:(list Z)) : Prop := forall (m:Z), ~ (mem1 m c).

Parameter witness: Z.

(* Why3 assumption *)
Definition nth (i:Z) (c:(list Z)) : Z :=
  match list.Nth.nth i c with
  | (Init.Datatypes.Some v) => v
  | Init.Datatypes.None => witness
  end.

Axiom nth_spec :
  forall (i:Z) (c:(list Z)),
  ((0%Z <= i)%Z /\ (i < (list.Length.length c))%Z) -> ~ ((nth i c) = witness).

Axiom inj_nth :
  forall (i:Z) (j:Z) (c:(list Z)),
  ((0%Z <= i)%Z /\ (i < (list.Length.length c))%Z) ->
  ((0%Z <= j)%Z /\ (j < (list.Length.length c))%Z) -> ~ (i = j) ->
  ~ ((nth i c) = (nth j c)).

(* Why3 assumption *)
Definition subset1 (c1:(list Z)) (c2:(list Z)) : Prop :=
  forall (k:Z), (mem1 k c1) -> mem1 k c2.

Axiom subset_nth :
  forall (c1:(list Z)) (c2:(list Z)), (subset1 c1 c2) -> forall (k:Z),
  ((0%Z <= k)%Z /\ (k < (list.Length.length c1))%Z) -> mem1 (nth k c1) c2.

Axiom subset_nth1 :
  forall (c1:(list Z)) (c2:(list Z)),
  (forall (k:Z), ((0%Z <= k)%Z /\ (k < (list.Length.length c1))%Z) ->
   mem1 (nth k c1) c2) ->
  subset1 c1 c2.

Axiom split_mem :
  forall {a:Type} {a_WT:WhyType a},
  forall (l:(list a)) (x:a) (y:a), (list.Mem.mem x l) ->
  list.Mem.mem x
  (Init.Datatypes.app l (Init.Datatypes.cons y Init.Datatypes.nil)).

Axiom split_mem1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (l:(list a)) (x:a) (y:a), (x = y) ->
  list.Mem.mem x
  (Init.Datatypes.app l (Init.Datatypes.cons y Init.Datatypes.nil)).

Axiom split_mem2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (l:(list a)) (x:a) (y:a),
  (list.Mem.mem x
   (Init.Datatypes.app l (Init.Datatypes.cons y Init.Datatypes.nil))) ->
  (list.Mem.mem x l) \/ (x = y).

Axiom asset : Type.
Parameter asset_WhyType : WhyType asset.
Existing Instance asset_WhyType.

Axiom entry : Type.
Parameter entry_WhyType : WhyType entry.
Existing Instance entry_WhyType.

Axiom field : Type.
Parameter field_WhyType : WhyType field.
Existing Instance field_WhyType.

(* Why3 assumption *)
Inductive action :=
  | Add : action
  | Rm : action
  | Get : action
  | Update : field -> action
  | Loop : action.
Axiom action_WhyType : WhyType action.
Existing Instance action_WhyType.

(* Why3 assumption *)
Inductive trace :=
  | mk_trace : entry -> asset -> action -> trace.
Axiom trace_WhyType : WhyType trace.
Existing Instance trace_WhyType.

(* Why3 assumption *)
Definition action1 (v:trace) : action :=
  match v with
  | mk_trace x x1 x2 => x2
  end.

(* Why3 assumption *)
Definition asset1 (v:trace) : asset :=
  match v with
  | mk_trace x x1 x2 => x1
  end.

(* Why3 assumption *)
Definition entry1 (v:trace) : entry :=
  match v with
  | mk_trace x x1 x2 => x
  end.

(* Why3 assumption *)
Definition log := (list trace).

(* Why3 assumption *)
Definition performed_by_role (tr:(list trace)) (e:env) (a:(list action))
    (r:(list Z)) : Prop :=
  forall (x:trace), (list.Mem.mem (action1 x) a) -> (list.Mem.mem x tr) ->
  list.Mem.mem (caller_ e) r.

(* Why3 assumption *)
Definition performed_by_tx (tr:(list trace)) (tx2:(option entry)) (tx1:entry)
    (a:action) (l:(list entry)) : Prop :=
  forall (x:trace), (list.Mem.mem x tr) ->
  ((Init.Datatypes.Some tx1) = tx2) -> ((action1 x) = a) ->
  list.Mem.mem tx1 l.

(* Why3 assumption *)
Inductive asset2 :=
  | Mile : Z -> asset2
  | Owner : Z -> asset2.
Axiom asset2_WhyType : WhyType asset2.
Existing Instance asset2_WhyType.

(* Why3 assumption *)
Inductive entry2 :=
  | Add1 : entry2
  | Consume : entry2.
Axiom entry2_WhyType : WhyType entry2.
Existing Instance entry2_WhyType.

(* Why3 assumption *)
Inductive field1 :=
  | Amount : field1
  | Expiration : field1
  | Miles : field1.
Axiom field1_WhyType : WhyType field1.
Existing Instance field1_WhyType.

(* Why3 assumption *)
Inductive action2 :=
  | Add2 : action2
  | Rm1 : action2
  | Get1 : action2
  | Update1 : field1 -> action2
  | Loop1 : action2.
Axiom action2_WhyType : WhyType action2.
Existing Instance action2_WhyType.

(* Why3 assumption *)
Inductive trace1 :=
  | mk_trace1 : entry2 -> asset2 -> action2 -> trace1.
Axiom trace1_WhyType : WhyType trace1.
Existing Instance trace1_WhyType.

(* Why3 assumption *)
Definition action3 (v:trace1) : action2 :=
  match v with
  | mk_trace1 x x1 x2 => x2
  end.

(* Why3 assumption *)
Definition asset3 (v:trace1) : asset2 :=
  match v with
  | mk_trace1 x x1 x2 => x1
  end.

(* Why3 assumption *)
Definition entry3 (v:trace1) : entry2 :=
  match v with
  | mk_trace1 x x1 x2 => x
  end.

(* Why3 assumption *)
Definition log1 := (list trace1).

(* Why3 assumption *)
Definition performed_by_role1 (tr:(list trace1)) (e:env) (a:(list action2))
    (r:(list Z)) : Prop :=
  forall (x:trace1), (list.Mem.mem (action3 x) a) -> (list.Mem.mem x tr) ->
  list.Mem.mem (caller_ e) r.

(* Why3 assumption *)
Definition performed_by_tx1 (tr:(list trace1)) (tx2:(option entry2))
    (tx1:entry2) (a:action2) (l:(list entry2)) : Prop :=
  forall (x:trace1), (list.Mem.mem x tr) ->
  ((Init.Datatypes.Some tx1) = tx2) -> ((action3 x) = a) ->
  list.Mem.mem tx1 l.

(* Why3 assumption *)
Inductive storage :=
  | mk_storage : Z -> (list Z) -> (Z -> Z) -> (Z -> Z) -> (list Z) ->
      (Z -> (list Z)) -> (list trace1) -> (option entry2) -> storage.
Axiom storage_WhyType : WhyType storage.
Existing Instance storage_WhyType.

(* Why3 assumption *)
Definition ename (v:storage) : (option entry2) :=
  match v with
  | mk_storage x x1 x2 x3 x4 x5 x6 x7 => x7
  end.

(* Why3 assumption *)
Definition tr (v:storage) : (list trace1) :=
  match v with
  | mk_storage x x1 x2 x3 x4 x5 x6 x7 => x6
  end.

(* Why3 assumption *)
Definition owner_miles (v:storage) : Z -> (list Z) :=
  match v with
  | mk_storage x x1 x2 x3 x4 x5 x6 x7 => x5
  end.

(* Why3 assumption *)
Definition owners (v:storage) : (list Z) :=
  match v with
  | mk_storage x x1 x2 x3 x4 x5 x6 x7 => x4
  end.

(* Why3 assumption *)
Definition mile_expirations (v:storage) : Z -> Z :=
  match v with
  | mk_storage x x1 x2 x3 x4 x5 x6 x7 => x3
  end.

(* Why3 assumption *)
Definition mile_amounts (v:storage) : Z -> Z :=
  match v with
  | mk_storage x x1 x2 x3 x4 x5 x6 x7 => x2
  end.

(* Why3 assumption *)
Definition miles (v:storage) : (list Z) :=
  match v with
  | mk_storage x x1 x2 x3 x4 x5 x6 x7 => x1
  end.

(* Why3 assumption *)
Definition admin (v:storage) : Z :=
  match v with
  | mk_storage x x1 x2 x3 x4 x5 x6 x7 => x
  end.

Axiom Amount_gt0 : forall (s:storage) (m:Z), (0%Z < ((mile_amounts s) m))%Z.

(* Why3 assumption *)
Definition get_amount (s:storage) (k:Z) : Z := (mile_amounts s) k.

(* Why3 assumption *)
Definition get_expiration (s:storage) (k:Z) : Z := (mile_expirations s) k.

(* Why3 assumption *)
Definition get_miles (s:storage) (o:Z) : (list Z) := (owner_miles s) o.

Parameter part_sum: storage -> (list Z) -> Z -> Z -> Z.

(* Why3 assumption *)
Definition sum (s:storage) (c:(list Z)) : Z :=
  part_sum s c 0%Z (list.Length.length c).

Axiom part_sum_def_empty :
  forall (s:storage) (c:(list Z)) (i:Z) (j:Z), (j <= i)%Z ->
  ((part_sum s c i j) = 0%Z).

Axiom part_sum_def_non_empty :
  forall (s:storage) (c:(list Z)) (i:Z) (j:Z), (i < j)%Z ->
  ((part_sum s c i j) = ((get_amount s i) + (part_sum s c (i + 1%Z)%Z j))%Z).

Axiom part_sum_right_extension :
  forall (s:storage) (c:(list Z)) (i:Z) (j:Z), (i < j)%Z ->
  ((part_sum s c i j) =
   ((part_sum s c i (j - 1%Z)%Z) + (get_amount s (nth (j - 1%Z)%Z c)))%Z).

Axiom part_sum_transitivity :
  forall (s:storage) (c:(list Z)) (i:Z) (k:Z) (j:Z),
  ((i <= k)%Z /\ (k <= j)%Z) ->
  ((part_sum s c i j) = ((part_sum s c i k) + (part_sum s c k j))%Z).

Axiom part_sum_eq :
  forall (s:storage) (c1:(list Z)) (c2:(list Z)) (i:Z) (j:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k < j)%Z) -> (mem1 k c1) /\ (mem1 k c2)) ->
  ((part_sum s c1 i j) = (part_sum s c2 i j)).

Axiom part_sum_extension :
  forall (s1:storage) (s2:storage) (c:(list Z)) (i:Z) (j:Z) (m:Z),
  (forall (k:Z), ((i <= k)%Z /\ (k <= j)%Z) -> ~ ((nth k c) = m) ->
   ((get_amount s1 (nth k c)) = (get_amount s2 (nth k c)))) ->
  (((part_sum s1 c i j) - (get_amount s1 m))%Z =
   ((part_sum s2 c i j) - (get_amount s2 m))%Z).

Axiom Owners_miles_part_1 :
  forall (s:storage) (m:Z) (o:Z), (mem1 o (owners s)) ->
  (mem1 m (get_miles s o)) -> mem1 m (miles s).

Axiom Owners_miles_part_2 :
  forall (s:storage) (m:Z) (o:Z), (mem1 o (owners s)) ->
  (mem1 m (miles s)) -> mem1 m (get_miles s o).

Parameter filter_consume: env -> storage -> (list Z) -> (list Z).

Axiom filter_consume_def :
  forall (e:env) (s:storage) (c:(list Z)),
  match c with
  | Init.Datatypes.nil => ((filter_consume e s c) = Init.Datatypes.nil)
  | (Init.Datatypes.cons a tl) =>
      (((now_ e) < (get_expiration s a))%Z ->
       ((filter_consume e s c) =
        (Init.Datatypes.cons a (filter_consume e s tl)))) /\
      (~ ((now_ e) < (get_expiration s a))%Z ->
       ((filter_consume e s c) = (filter_consume e s tl)))
  end.

Axiom filter_consume_spec :
  forall (e:env) (s:storage) (c:(list Z)), forall (a:Z),
  (mem1 a (filter_consume e s c)) -> ((now_ e) < (get_expiration s a))%Z.

Axiom filter_consume_spec1 :
  forall (e:env) (s:storage) (c:(list Z)), subset1 (filter_consume e s c) c.

Parameter filter_clear_expired: env -> storage -> (list Z) -> (list Z).

Axiom filter_clear_expired_def :
  forall (e:env) (s:storage) (c:(list Z)),
  match c with
  | Init.Datatypes.nil => ((filter_clear_expired e s c) = Init.Datatypes.nil)
  | (Init.Datatypes.cons a tl) =>
      (((get_expiration s a) < (now_ e))%Z ->
       ((filter_clear_expired e s c) =
        (Init.Datatypes.cons a (filter_clear_expired e s tl)))) /\
      (~ ((get_expiration s a) < (now_ e))%Z ->
       ((filter_clear_expired e s c) = (filter_clear_expired e s tl)))
  end.

Axiom filter_clear_expired_spec :
  forall (e:env) (s:storage) (c:(list Z)), forall (a:Z),
  (mem1 a (filter_clear_expired e s c)) ->
  ((get_expiration s a) < (now_ e))%Z.

Axiom filter_clear_expired_spec1 :
  forall (e:env) (s:storage) (c:(list Z)),
  subset1 (filter_clear_expired e s c) c.

(* Why3 goal *)
Theorem VC_clear_expired :
  forall (e:env) (s:storage), ((caller_ e) = (admin s)) ->
  let o := ((list.Length.length (owners s)) - 1%Z)%Z in
  (0%Z <= (o + 1%Z)%Z)%Z -> forall (s1:storage),
  (((admin s1) = (admin s)) /\
   (((mile_amounts s1) = (mile_amounts s)) /\
    (((mile_expirations s1) = (mile_expirations s)) /\
     (((owners s1) = (owners s)) /\
      (((tr s1) = (tr s)) /\ ((ename s1) = (ename s))))))) ->
  forall (i:Z), ((0%Z <= i)%Z /\ (i <= o)%Z) ->
  let o1 := nth i (owners s1) in
  ~ (o1 = witness) ->
  let miles1 := get_miles s1 o1 in
  let l := filter_clear_expired e s1 miles1 in
  ((forall (a:Z), (mem1 a l) -> ((get_expiration s1 a) < (now_ e))%Z) /\
   (subset1 l miles1)) ->
  let o2 := ((list.Length.length l) - 1%Z)%Z in
  (0%Z <= (o2 + 1%Z)%Z)%Z -> forall (s2:storage),
  (((admin s2) = (admin s1)) /\
   (((mile_amounts s2) = (mile_amounts s1)) /\
    (((mile_expirations s2) = (mile_expirations s1)) /\
     (((owners s2) = (owners s1)) /\
      (((tr s2) = (tr s1)) /\ ((ename s2) = (ename s1))))))) ->
  forall (j:Z), ((0%Z <= j)%Z /\ (j <= o2)%Z) ->
  let m := nth j l in ~ (m = witness) -> mem1 m (miles s2).
Proof.
intros e s h1 o h2 s1 (h3,(h4,(h5,(h6,(h7,h8))))) i (h9,h10) o1 h11 miles1 l
(h12,h13) o2 h14 s2 (h15,(h16,(h17,(h18,(h19,h20))))) j (h21,h22) m h23.

Qed.

