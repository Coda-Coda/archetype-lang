module Miles

  use int.Int
  use ref.Ref
  use option.Option
  use list.List

  use archetype.Types
  use archetype.Contract
  use archetype.Map
  use archetype.AssetCollection
  use archetype.Trace

(* TRACES *)

  type asset =
  | Mile key
  | Owner key

  type entry =
  | Add 
  | Consume

  type field = 
  | Amount
  | Expiration
  | Miles

  clone archetype.Trace as Tr with type asset = asset,
                                   type entry = entry, 
                                   type field = field
  type storage = {
    mutable admin            : role;
    mutable miles            : acol;
    mutable mile_amounts     : map int;
    mutable mile_expirations : map date;
    mutable owners           : acol;
    mutable owner_miles      : map acol;
    (* others *)
    mutable tr               : Tr.log;
    mutable ename            : option entry;
  }
  
  (* TODO : make this a storage invariant *)
  axiom Amount_gt0 : forall s : storage, m : key. get s.mile_amounts m > 0 

  let function get_mile       (s : storage) (k : key) : key = k
  let function get_amount     (s : storage) (k : key) : int = get s.mile_amounts k
  let function get_expiration (s : storage) (k : key) : date = get s.mile_expirations k

  let function get_owner (s : storage) (o : key) : key = o
  let function get_miles (s : storage) (o : key) : acol  = get s.owner_miles o

  clone archetype.Sum as Amounts with type     storage = storage,
                                      function f       = get_amount

  (* Owner.miles is a partition of s.miles *)

  axiom Owners_miles_part_1 : forall s : storage, m : key, o : key.
    mem o s.owners ->
    let miles = get_miles s o in
    mem m miles -> mem m s.miles

  axiom Owners_miles_part_2 : forall s : storage, m : key, o : key.
    mem o s.owners ->
    let miles = get_miles s o in
    mem m s.miles -> mem m miles

  let remove_miles (o : key) (m : key) (s:storage) : unit
  requires { mem m s.miles }
  requires { mem o s.owners }
  ensures  { Amounts.sum (old s) (old s).miles = Amounts.sum s s.miles + get_amount (old s) m }
  ensures  { forall x:key. mem x s.miles <-> (mem x (old s).miles /\ x <> m) }
  =
    s.miles <- remove m s.miles;
    let miles = get_miles s o in
    let new_owner_miles = remove m miles in 
    s.owner_miles <- set s.owner_miles o new_owner_miles

  let add_miles (o : key) (m : key) (a : int) (e : date) (s : storage) : unit
  requires { mem o s.owners }
  requires { not (mem m s.miles) }
  ensures  { Amounts.sum (old s) (old s).miles + a = Amounts.sum s s.miles }
  ensures  { forall x:key. mem x s.miles <-> (mem x (old s).miles \/ x = m) }
  =
    s.miles <- add m s.miles;
    s.mile_amounts <- set s.mile_amounts m a;
    s.mile_expirations <- set s.mile_expirations m e;
    let miles = get_miles s o in
    let new_owner_miles = add m miles in
    s.owner_miles <- set s.owner_miles o new_owner_miles

  let set_amount (m : key) (a : int) (s : storage) : unit
  requires { mem m s.miles }
  ensures  { Amounts.sum (old s) (old s).miles = Amounts.sum s s.miles - a + get_amount (old s) m }
  ensures { (old s).miles = s.miles }
  = s.mile_amounts <- set s.mile_amounts m a

  let update_owner (o : key) (new_miles : acol) (s : storage) : unit
  raises { NotFound }
  = 
  if not (mem o s.owners) then raise NotFound;
  s.owner_miles <- set s.owner_miles o new_miles  

  let addifnotexist (o : key) (new_miles : acol) (s : storage) : unit
  raises { NotFound }
  =
  if not (mem o s.owners) then update_owner o new_miles s

  (* Actions  *****************************************************************)

  let add (e : env) (s : storage) (ow : key) (m : key) (a : int) (ex : date) : transfers 
  raises { InvalidCaller, InvalidCondition, NotFound }
  =
    if caller e <> s.admin then raise InvalidCaller;
    if not (a > 0) then raise InvalidCondition;
    addifnotexist ow Nil s;
    add_miles ow m a ex s;
    Contract.empty

  let rec function filter_consume (e : env) (s : storage) (c : acol) : acol
  variant { c }
  ensures { forall a : key. mem a result -> get_expiration s a > now e }
  ensures { subset result c }
  =
  match c with
  | Nil -> Nil
  | Cons a tl ->
    if get_expiration s a > now e
    then Cons a (filter_consume e s tl)
    else filter_consume e s tl
  end

  let consume (e : env) (s : storage) (owner : address) (nbmiles : int) : transfers
  raises { InvalidCaller }
  requires { nbmiles > 0 }
  requires { let o = get_owner s owner in mem o s.owners }
  requires { forall m : key, s : storage. get_amount s m > 0 }
  requires {
     let o = get_owner s owner in
     let miles = get_miles s o in
     let l = filter_consume e s miles in
     Amounts.sum s l >= nbmiles
  }
  (* forall m : removed miles, m.expiration > now *)
  ensures { forall m : key.
     mem m (diff (old s).miles s.miles) ->  get_expiration s m > (now e)
  }
  (* mile.sum(quantity) = before miles.sum(quantity) - nbmiles *)
  ensures { Amounts.sum (old s) (old s).miles = Amounts.sum s s.miles + nbmiles }
  (* is_emtpy add.miles *)
  ensures { is_empty (diff s.miles (old s).miles) }

  = if caller e <> s.admin then raise InvalidCaller;
    let remainder = ref nbmiles in
    let o = get_owner s owner in
    let miles = get_miles s o in
    let l = filter_consume e s miles in
    try
      for i = 0 to (length l) - 1 do
      (* helps for the membership precondition of set_amount: *)
      invariant { forall k : int. i <= k < length l ->  mem (nth k l) s.miles }
      (* removed miles are in l: *)
      invariant { subset (diff (old s).miles s.miles) l }
      (* remainder bounds: *)
      invariant { 0 <= !remainder <= Amounts.part_sum s l i (length l) }
      (* right amount spent invariant *)
      invariant { Amounts.sum (old s) (old s).miles = Amounts.sum s s.miles + nbmiles - !remainder }
      (* no added mile : TODO replace by trace proof *)
      invariant { is_empty (diff s.miles (old s).miles) }
        let m = nth i l in
        if get_amount s m > !remainder
        then
          (set_amount m (get_amount s m - !remainder) s;
           remainder := 0;
           raise Break)
        else if get_amount s m = !remainder
        then
          (remainder := 0;
           remove_miles o m s;
           raise Break)
        else
          (remainder := !remainder - get_amount s m;
           remove_miles o m s)
      done;
    with Break -> assert { !remainder = 0 }; ()
    end;
    assert { !remainder = 0 };
    Contract.empty

    let rec function filter_clear_expired (e : env) (s : storage) (c : acol) 
    variant { c }
    ensures { forall a : key. mem a result -> get_expiration s a < now e }
    ensures { subset result c }
    = match c with
      | Nil -> Nil
      | Cons a tl ->
        if get_expiration s a < now e
        then Cons a (filter_clear_expired e s tl)
        else filter_clear_expired e s tl
      end

    let clear_expired (e : env) (s : storage) (owner : address) : transfers 
    raises { InvalidCaller }
    ensures { forall m : key. mem m (diff (old s).miles s.miles) -> get_expiration s m < now e }
    = if caller e <> s.admin then raise InvalidCaller;
      for i = 0 to (length s.owners)-1 do
        let o = nth i s.owners in
        let miles = get_miles s o in
        let l = filter_clear_expired e s miles in
        for j = 0 to (length l) - 1 do
          let m = nth j l in
          remove_miles o m s;
        done;
      done;
      Contract.empty

end