module Miles_with_expiration_storage

    use archetype.Lib

    (* TRACES *)

   type asset =
    | Mile
    | Owner

    type entry =
    | Add
    | Consume
    | ClearExpired

    type field =
    | Amount
    | Expiration
    | Miles

    clone archetype.Trace as Tr with type asset = asset,
                                     type entry = entry,
                                     type field = field 
    
    (* ASSETS *)
     type mile = {
        amount: int;
        expiration : date;
    } 
    
    let mk_default_mile () = { amount = 0; expiration = 0; } : mile

    type owner = {
        miles      : acol;
    } 

    let mk_default_owner () : owner = { miles = empty; } : owner

    type storage = {
        mutable admin            : role;
        mutable mile_keys        : acol;
        mutable mile_assets      : map mile;
        mutable owner_keys       : acol;
        mutable owner_assets     : map owner;
         (* contract *)
        mutable ops              : transfers;
        (* diff sets *)
        mutable miles_added      : acol;
        mutable miles_removed    : acol;
        mutable owner_added      : acol;
        mutable owner_removed    : acol;
        (* traces *)
        mutable tr               : Tr.log;
        mutable ename            : option entry; 
    } (*invariant { 
        forall k: key. mem k owner_keys -> subset (miles (get owner_assets k)) mile_keys
    } *)invariant { 
        forall k : key. mem k mile_keys -> amount (get mile_assets k) > 0
    } by {
        admin                    = 0;
        mile_keys                = empty;
        mile_assets              = const (mk_default_mile ());
        owner_keys               = empty;
        owner_assets             = const (mk_default_owner ());
        ops                      = Nil;
        miles_added              = empty;
        miles_removed            = empty;
        owner_added              = empty;
        owner_removed            = empty;
        tr                       = Nil;
        ename                    = None;
    }

    (* Getters ----------------------------------------------------------------*)

    let function get_amount  (s : storage) (k : key) : int = amount (get s.mile_assets k)

    let function get_expiration  (s : storage) (k : key) : int = expiration (get s.mile_assets k)

    let function get_miles (s : storage) (k : key) : acol = miles (get s.owner_assets k)

    let get_mile (s : storage) (k : key) : mile 
    raises { NotFound }
    ensures { mem k s.mile_keys }
    = 
    if not (mem k s.mile_keys) then
        raise NotFound
    else 
        get s.mile_assets k 

    let get_owner (s : storage) (k : key) : owner 
    raises { NotFound }
    ensures { mem k s.owner_keys }
    = 
    if not (mem k s.owner_keys) then
        raise NotFound
    else 
        get s.owner_assets k  

    (* Operations -------------------------------------------------------------*)

    clone archetype.Sum as Amounts with type     storage = storage,
                                        val      f       = get_amount

   (*let function set_miles_to_storage  (c : acol) (l : list mile) (s : storage): storage
    requires { card c = length l }
    requires {  forall a : mile. (exists i : int. 0 <= i < length l /\ a = gen_nth i l) -> amount a > 0 }
    ensures { forall x : key. mem x (mile_keys s) -> get_amount s x = get_amount result x }
    = { 
        s with 
        mile_keys   = c;
        mile_assets = to_map c l s.mile_assets;
    }

    let function set_miles_keys_to_storage (s : storage) (c : acol) : storage
    requires { subset c s.mile_keys }
    = {
        s with
        mile_keys   = c;
    }*)
   
    (* Setters --------------------------------------------------------------*)

(*    let set_amount (s : storage) (k : key) (v : int) : unit
    raises { NotFound }
    requires { v > 0 }
    ensures { mem k s.mile_keys }
    ensures { Amounts.sum (old s) (old s).mile_keys = Amounts.sum s s.mile_keys - v + get_amount (old s) k }
    ensures { get_amount s k = v }
    =
    if not (mem k s.mile_keys) then
        raise NotFound
    else 
        let asset = get_mile s k in
        let new_asset = { asset with amount = v } in
        s.mile_assets <- set s.mile_assets k new_asset
*)  
    (* Adders ---------------------------------------------------------------*)

    (* is not called by actions because it is partitioned *)
    let add_mile (s : storage) (k : key) (new_mile : mile) : unit
    raises { KeyExist }
    requires { amount new_mile > 0 }
    ensures { mem k s.mile_keys }
    (* set operations *)
    ensures { s.mile_keys == union (old s).mile_keys (singleton k) }
    ensures { is_empty (inter (old s).mile_keys (singleton k)) }
    (* operations *)
    ensures { Amounts.sum s s.mile_keys = Amounts.sum (old s) (old s).mile_keys + amount new_mile }
    ensures { forall k : key. mem k (old s).mile_keys -> get_amount s k = get_amount (old s) k }
    ensures { card s.mile_keys = card (old s).mile_keys + 1 }
    =
    if mem k s.mile_keys then
        raise KeyExist
    else
        s.mile_keys <- add k s.mile_keys;
        s.mile_assets <- set s.mile_assets k new_mile

    (* add a mile through an owner *)
    let add_owner_mile (s : storage) (k : key) (mile_k : key) (new_mile : mile) : unit
    raises { NotFound, KeyExist }
    requires { amount new_mile > 0 }
    ensures { mem mile_k s.mile_keys }
    (* set operations *)
    ensures { s.mile_keys == union (old s).mile_keys (singleton mile_k) /\ is_empty (inter (old s).mile_keys (singleton mile_k)) }
    (* operations *)
    ensures { Amounts.sum s s.mile_keys = Amounts.sum (old s) (old s).mile_keys + amount new_mile }
    ensures { forall k : key. mem k (old s).mile_keys -> get_amount s k = get_amount (old s) k }
    ensures { card s.mile_keys = card (old s).mile_keys + 1 }
    =
    if not (mem k s.owner_keys) then
        raise NotFound
    else
        (add_mile s mile_k new_mile;
         (* update miles *)
         let owner_asset = get_owner s k in
         let owner_miles = miles owner_asset in
         let new_owner_miles = add mile_k owner_miles in
         let new_owner_asset = { owner_asset with 
            miles = new_owner_miles;
         } in
         s.owner_assets <- set s.owner_assets k new_owner_asset)
    
    let add_owner (s : storage) (k : key) (new_owner : owner) (assets : list mile) : unit
    raises { KeyExist, NotFound }
    (* input consistency *)
    requires { let asset_keys = miles new_owner in card asset_keys = length assets }
    (* mile invariant *)
    requires {  forall a : mile, i : int. 0 <= i < length assets -> a = gen_nth i assets -> amount a > 0 }
    ensures { mem k s.owner_keys }
    (* basic set operation *)
    ensures { s.owner_keys == union (old s).owner_keys (singleton k) /\ inter (old s).owner_keys (singleton k) == empty }
    ensures { 
        let asset_keys = miles new_owner in
        s.mile_keys == union (old s).mile_keys asset_keys /\ (inter (old s).mile_keys asset_keys == empty)
    }
    (* count operation *)
    ensures { card s.owner_keys = card (old s).owner_keys + 1 }
    ensures { 
        let  asset_keys = miles new_owner in 
        card s.mile_keys = card (old s).mile_keys + card asset_keys 
    }
    (* sum operation *)
    ensures { forall k : key. mem k (old s).mile_keys -> get_amount s k = get_amount (old s) k }
    ensures { 
        let asset_keys = miles new_owner in 
        (* let astorage = set_miles_to_storage asset_keys assets s in *)
        Amounts.sum s s.mile_keys = Amounts.sum (old s) (old s).mile_keys + Amounts.sum s asset_keys 
    }
    =
    if mem k s.owner_keys then
        raise KeyExist
    else
        s.owner_keys <- add k s.owner_keys;
        s.owner_assets <- set s.owner_assets k new_owner;
        let asset_keys = miles new_owner in
        for i = 0 to (card asset_keys) - 1 do
        invariant { s.mile_keys == union (old s).mile_keys (head i asset_keys) }
        invariant { is_empty (inter (old s).mile_keys (head i asset_keys)) }
        invariant { forall k : key. mem k s.mile_keys -> amount (get s.mile_assets k) > 0  }
        invariant { forall k : key. mem k (old s).mile_keys -> get_amount s k = get_amount (old s) k }
            let ak = nth i asset_keys in
            let asset = gen_nth i assets in
            add_owner_mile s k ak asset
        done

    (* Removers ---------------------------------------------------------------*)

    let remove_mile (s : storage) (k : key) : unit
    raises { NotFound }
    ensures { not (mem k s.mile_keys) }
    (* set effect *)
    ensures { s.mile_keys == diff (old s).mile_keys (singleton k) }
    (* operations *)
    ensures {  Amounts.sum s s.mile_keys = Amounts.sum (old s) (old s).mile_keys - (get_amount (old s) k) }
    ensures { card s.mile_keys = card (old s).mile_keys - 1 }
    =
    if not (mem k s.mile_keys) then
        raise NotFound
    else
        s.mile_keys <- remove k s.mile_keys

    (* remove a mile through an owner *)
    let remove_owner_mile (s : storage) (k : key) (mile_k : key) : unit
    raises { NotFound }
    ensures { not (mem mile_k s.mile_keys) }
    (* set effect *)
    ensures { s.mile_keys == diff (old s).mile_keys (singleton mile_k) }
    (* operations *)
    ensures { Amounts.sum s s.mile_keys = Amounts.sum (old s) (old s).mile_keys - (get_amount (old s) mile_k) }
    ensures { card s.mile_keys = card (old s).mile_keys - 1 }
    =
    if not (mem k s.owner_keys) then
        raise NotFound
    else
        (remove_mile s mile_k;
         (* update miles *)
         let owner_asset = get_owner s k in
         let owner_miles = miles owner_asset in
         let new_owner_miles = remove mile_k owner_miles in
         let new_owner_asset = { owner_asset with 
            miles = new_owner_miles;
         } in
         s.owner_assets <- set s.owner_assets k new_owner_asset)
    
    let remove_owner (s : storage) (k : key) : unit
    raises { NotFound }
    (* partition property *)
    requires { mem k s.owner_keys -> subset (miles (get s.owner_assets k)) s.mile_keys }
    ensures { not (mem k s.owner_keys) }
    (* set effect *)
    ensures { s.owner_keys == diff (old s).owner_keys (singleton k) }
    ensures { 
        let asset_keys = get_miles (old s) k in
        s.mile_keys == diff (old s).mile_keys asset_keys 
    }
    (*ensures {
        let assets = get_miles (old s) k in 
        subset assets (old s).mile_keys 
    }*)
    (* count operation *)
    ensures { card s.owner_keys = card (old s).owner_keys - 1 }
    ensures { 
        let assets = get_miles (old s) k in
        card s.mile_keys = card (old s).mile_keys - card assets 
    }
    (* sum operation *)
    ensures { 
        let asset_keys = get_miles (old s) k in 
        Amounts.sum s s.mile_keys = Amounts.sum (old s) (old s).mile_keys - Amounts.sum (old s) asset_keys 
    }
    =
    if not (mem k s.owner_keys) then
        raise NotFound
    else
        s.owner_keys <- remove k s.owner_keys;
        let assets = get_miles s k in
        for i = 0 to (card assets) - 1 do
        invariant { s.mile_keys == diff (old s).mile_keys (head i assets)}
        (*invariant { subset (head i assets) (old s).mile_keys }*)
        invariant { forall k : key. mem k s.mile_keys -> amount (get s.mile_assets k) > 0  }
            let ak = nth i assets in
            remove_mile s ak 
        done
    
end