theory Types

  use int.Int
  use mach.int.UInt32

  (* default type mapping *)
  type key     = int
  type role    = int
  type address = int
  type uint    = uint32
  type tez     = int
  type date    = int
  type string  = int

  constant max_uint : int = UInt32.max_uint32

  exception Break
  exception NotFound
  exception KeyExist
  exception InvalidCaller
  exception InvalidCondition

end

theory Contract

  use Types
  use int.Int
  use mach.int.UInt32
  use list.List
  use list.Append
  use array.Array

  (* currency transfer during transaction *)
  type transfer = {
     destination : address;
     amount      : tez;
  }

  type transfers = list transfer

  let empty : transfers = Nil

  type env = {
     mutable balance_ : tez;
     (* transaction env *)
     transferred_     : tez;
     caller_          : address;
     now_             : date;
  }

  let empty_env () : env = { balance_ = 0; transferred_ = 0; caller_ = 0; now_ = 0 }

  let function balance (e: env) : tez = e.balance_

  let function transferred (e : env) : tez = e.transferred_

  let function caller (e : env) : address = e.caller_

  let function now (e : env) : date = e.now_

  let update_balance (e : env)
    requires { transferred e + balance e <= max_uint }
    ensures  { balance e = old (balance e) + (transferred e)}
  =
    let part_sum = e.balance_ + e.transferred_ in
    e.balance_ <- part_sum

  let exec_transfer (e : env) (a : address) (c : tez) (ops : transfers) : transfers
    requires { c <= balance e }
    ensures  { old (balance e) = (balance e) + c }
  =
    e.balance_ <- e.balance_ - c;
    let transfer = { destination = a; amount = c } in
    ops ++ (Cons transfer Nil)

end

(* non ghost map *)
module Map

  (* import non ghost equality on integer *)
  use int.Int
  use Types

  type map 'value = key -> 'value

  let function get (f: map 'value) (x: key) : 'value = f x

  let function set (f: map 'value) (x: key) (v: 'value) : map 'value 
  ensures { forall k : key. k <> x -> result k = f k }
  = fun (y : key) -> if y = x then v else f y

  let function const (v : 'value) : map 'value = fun _ -> v

end

(* Set with : mem length add remove diff nth
  implemented with list type
 *)
theory AssetCollection

  use list.List
  use list.Length
  use list.Elements
  use list.Append
  use list.Nth
  use list.Mem
  use option.Option
  use int.Int

  use Types
  use Contract
  use Map

  (* asset collection *)
  type acol = list key

  let rec predicate mem (k : key) (c : acol) : bool 
  variant { c }
  = match c with
    | Cons e tl ->
      if e = k
      then true
      else mem k tl
    | Nil -> false
    end

  predicate (==) (c1 c2 : acol) = forall k : key. mem k c1 <-> mem k c2

  let function length (c : list 'a) = length c

  lemma mem_exists: forall k : int, c : acol.
    not (mem k c) <-> forall i : int. 0 <= i <= length c -> i <> k

  let add (a : key) (c : acol)
  raises { KeyExist }
  ensures { not (mem a (old c)) }
  ensures { mem a result }
  ensures { forall k : key. mem k result <-> mem k c \/ k = a }
  ensures { length result = length c + 1 }
  = if mem a c then raise KeyExist;
    c ++ (Cons a Nil)

  let addifnotexist (a : key) (c : acol) : acol
  ensures { forall k : key. mem k result <-> mem k c \/ k = a }
  ensures { mem a result } 
  = if mem a c
    then c
    else c ++ (Cons a Nil)

  let rec remove (a : key) (c : acol) : acol
  raises { NotFound }
  variant { c }
  ensures { forall k : key. mem k result <-> mem k c /\ k <> a }
  =
     if not (mem a c) then raise NotFound;
     match c with
     | Nil -> Nil
     | Cons e tl ->
       if e = a
       then remove a tl
       else Cons e (remove a tl)
     end

  let rec function diff (c1 c2 : acol) : acol
  variant { c1 }
  ensures { forall x : key. mem x result <-> mem x c1 /\ not (mem x c2) }
  = match c1 with
  | Nil -> Nil 
  | Cons h tl -> 
    if mem h c2
    then diff tl c2
    else Cons h (diff tl c2)
  end

  let rec function inter (c1 c2 : acol) : acol
  variant { c1 }
  ensures { forall x : key. mem x result <-> mem x c1 /\ mem x c2 }
  = match c1 with
  | Nil -> Nil 
  | Cons h tl -> 
    if mem h c2
    then Cons h (inter tl c2)
    else inter tl c2
  end

  let rec function union (c1 c2 : acol) : acol
  variant { c1 }
  ensures { forall x : key. mem x result <-> mem x c1 \/ mem x c2 }
  = match c1 with
  | Nil -> c2 
  | Cons h tl -> 
    if mem h c2
    then union tl c2
    else union tl (Cons h c2)
  end

  predicate is_empty (c : acol) = forall m : key. not (mem m c)

  axiom zero_length : forall c : acol. is_empty c -> length c = 0

  val function witness : 'a

  let function gen_nth (i : int) (c : list 'a) : 'a
  = 
  match nth i c with
  | Some v -> v
  | None -> witness
  end

  let function nth (i : int) (c : acol) : key
  ensures { 0 <= i < length c -> result <> witness }
  ensures { 0 <= i < length c -> mem result c }
  = gen_nth i c

  (* this axiom ensures that all asset keys are unique, 
     which is translated to the injectivity of nth *)
  axiom inj_nth : forall i j : int, c : acol.
    0 <= i < length c ->
    0 <= j < length c ->
    i = j <-> nth i c = nth j c

  axiom inj_nth2 : forall i j : int, c : acol.
    0 <= i < length c ->
    0 <= j < length c ->
    i <> j ->
    nth i c <> nth j c  

  predicate subset (c1 c2 : acol)
  = forall k : key. mem k c1 -> mem k c2

  axiom subset_nth : forall c1 c2 : acol.
    subset c1 c2 <-> forall k : int. 0 <= k < length c1 -> mem (nth k c1) c2
  
  lemma subset_diff: forall c1 c2 : acol. subset (diff c1 c2) c1

  lemma subset_inter1: forall c1 c2 : acol. subset (inter c1 c2) c1

  lemma subset_inter2: forall c1 c2 : acol. subset (inter c1 c2) c2

  lemma subset_union1: forall c1 c2 : acol. subset c1 (union c1 c2)

  lemma subset_union2: forall c1 c2 : acol. subset c2 (union c1 c2) 

  (* not really used *)
  let rec fold (f : {'a} -> 'k -> 'a)
               (acc : {'a})
               (l : list 'k) : 'a
  variant { l } =
  match l with
  | Cons e tl -> fold f (f acc e) tl
  | Nil -> acc
  end

  axiom split_mem : forall l : list 'a, x y : 'a.
   Mem.mem x l \/ x = y <-> Mem.mem x (l ++ (Cons y Nil))    

  let rec add_to_map (c : acol) (l : list 'value) (m : map 'value)  
   variant { c, l }
   requires { length c = length l }
   ensures { forall k : key. mem k c -> exists i : int. 0 <= i < length c /\ gen_nth i l = get m k }
   =
   match (c,l) with
   | Nil,Nil -> m
   | Cons k tlacol, Cons a tlasset -> add_to_map tlacol tlasset (set m k a) 
   end


end

theory Filter
  use int.Int
  use list.List

  use Types
  use Contract
  use AssetCollection
  
  type storage = abstract mutable {}
  
  val function test env storage key : bool

  let rec function filter (e : env) (s : storage) (c : acol) : acol
  variant { c }
  ensures { forall a : key. mem a result -> test e s a }
  ensures { subset result c }
  =
  match c with
  | Nil -> Nil
  | Cons a tl ->
    if test e s a
    then Cons a (filter e s tl)
    else filter e s tl
  end

end

theory Sum

  (* import comparison operators on key *)
  use int.Int
  use list.List
  use Types
  use AssetCollection

  type storage = abstract mutable {}

  (* should it be generalized to any summable type  ? *)
  val function f storage key : int

  let function part_sum (s : storage) (c : acol) (i j : int) : int = 
    let rec rec_sum (k : int) (l : acol) 
    variant { l }
    = match l with
      | Cons e tl ->
        if i <= k <= j
        then f s e + rec_sum (k+1) tl 
        else rec_sum (k+1) tl
      | Nil -> 0
      end in
    rec_sum 0 c

  let function sum (s : storage) (c : acol) = part_sum s c 0 (length c)

  lemma part_sum_def_empty :
    forall s : storage, c: acol, i j : int.
    j <= i -> part_sum s c i j = 0

  lemma part_sum_def_non_empty :
    forall s : storage, c: acol, i j : int.
    i < j -> part_sum s c i j = f s (nth i c) + part_sum s c (i+1) j

  lemma part_sum_right_extension:
    forall s : storage, c : acol, i j : int.
    i < j -> part_sum s c i j = part_sum s c i (j-1) + f s (nth (j-1) c)

  lemma part_sum_transitivity :
    forall s : storage, c : acol, i k j : int. i <= k <= j ->
    part_sum s c i j = part_sum s c i k + part_sum s c k j

  lemma part_sum_eq :
    forall s : storage, c1 c2 : acol, i j : int.
    (forall k : int. i <= k < j -> mem k c1 /\ mem k c2) -> 
    part_sum s c1 i j = part_sum s c2 i j
      
  lemma part_sum_extension:
    forall s1 s2: storage, c : acol, i j m : int.
    (forall k : int. i <= k <= j -> nth k c <> m -> f s1 (nth k c) = f s2 (nth k c)) ->
    part_sum s1 c i j - f s1 m = part_sum s2 c i j - f s2 m

  lemma sum_remove:
    forall s1 s2 : storage, c1 c2 : acol, m : int.
     (mem m c2) ->
     (forall k : key. mem k c1 <-> mem k c2 /\ k<>m) -> (* c1 = c2 \ { m } *)
     (forall k : key. mem k c2 -> f s1 k = f s2 k) ->
     sum s1 c1 = sum s2 c2 - f s1 m

  lemma sum_add:
    forall s1 s2 : storage, c1 c2 : acol, m v : int.
     not (mem m c2) ->
     (forall k : key. mem k c1 <-> mem k c2 \/ k=m) -> (* c1 = c2 U { m } *)
     (forall k : key. mem k c2 -> f s1 k = f s2 k) ->
     f s1 m = v ->
     sum s1 c1 = sum s2 c2 + v

  lemma sum_inter:
    forall s : storage, c1 c2 : acol, i j : int.
    is_empty (inter c1 c2) ->
    part_sum s (union c1 c2) i j = part_sum s c1 i j + part_sum s c1 i j

end

theory Trace
  
  use list.List
  use list.Mem
  use option.Option

  use Types
  use Contract

  type asset
  type entry
  type field

  type action =
  | Add
  | Rm 
  | Get
  | Update field
  | Loop

  type trace =  {
    entry : entry;
    asset : asset;
    action : action;
  }
  
  type log = list trace

  let mk_trace (e : entry) (a : asset) (c : action) : log = Cons ({
    entry = e;
    asset = a;
    action = c;
  }) Nil

  predicate performed_only_by_role  (e : env) (tr : log) 
    (actions : list action)
    (assets  : list asset) 
    (roles   : list address) =
  forall x:trace. 
    Mem.mem (action x) actions -> 
    Mem.mem (asset x)  assets ->
    Mem.mem x tr -> 
    Mem.mem (caller e) roles

  predicate performed_only_by_action (e : env) (tr : log) 
    (actions : list action) 
    (assets  : list asset)  
    (entries : list entry) =
  forall x:trace.
    Mem.mem (action x) actions ->
    Mem.mem (asset x)  assets ->
    Mem.mem x tr ->
    Mem.mem (entry x) entries

end

module Lib
 
  use export int.Int
  use export ref.Ref
  use export option.Option
  use export list.List
  use export list.Append
  
  use export Types
  use export Contract
  use export Map
  use export AssetCollection
  use export Trace

end
