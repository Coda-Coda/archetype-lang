theory Types

  use int.Int
  use mach.int.UInt32

  (* default type mapping *)
  type key     = int
  type role    = int
  type address = int
  type uint    = uint32
  type tez     = uint32
  type date    = int
  type string  = int

  constant max_uint : int = UInt32.max_uint32

  exception Break
  exception NotFound

end

theory Contract

  use Types
  use int.Int
  use mach.int.UInt32
  use list.List
  use list.Append
  use set.Fset
  use set.FsetNth
  use set.FsetSum
  use array.Array

  (* currency transfer during transaction *)
  type transfer = {
     destination : address;
     amount      : tez;
  }

  type transfers = list transfer

  let empty : transfers = Nil

  type env = {
     mutable balance_ : tez;
     (* transaction env *)
     transferred_     : tez;
     caller_          : address;
     now_             : date;
  }

  let function balance (e: env) : tez = e.balance_

  let function transferred (e : env) : tez = e.transferred_

  let function caller (e : env) : address = e.caller_

  let function now (e : env) : date = e.now_

  let update_balance (e : env)
    requires { transferred e + balance e <= max_uint }
    ensures  { balance e = old (balance e) + (transferred e)}
  =
    let sum = e.balance_ + e.transferred_ in
    e.balance_ <- sum

  let exec_transfer (e : env) (a : address) (c : tez) (ops : transfers) : transfers
    requires { c <= balance e }
    ensures  { old (balance e) = (balance e) + c }
  =
    e.balance_ <- e.balance_ - c;
    let transfer = { destination = a; amount = c } in
    ops ++ (Cons transfer Nil)

end

(* non ghost map *)
module Map

  use int.Int

  type map 'value = int -> 'value

  let function get (f: map 'value) (x: int) : 'value = f x

  let function set (f: map 'value) (x: int) (v: 'value) : map 'value =
    fun (y : int) -> if y = x then v else f y

end

(* Set with : mem length add remove diff nth
  implemented with list type
 *)
theory Asset

  use list.List
  use list.Length
  use list.Elements
  use list.Append
  use list.Nth
  use set.Fset
  use option.Option
  use int.Int

  use Types
  use Contract
  use Map

  let rec predicate mem (k : int) (a : list int) : bool =
    match a with
    | Cons e tl ->
      if e = k
      then true
      else mem k tl
    | Nil -> false
    end

  let function length (c : list 'a) = length c

  let function add (a : 'a) (c : list 'a) = c ++ (Cons a Nil)

  let addifnotexist (a : int) (c : list int) : list int =
  if mem a c
  then c
  else c ++ (Cons a Nil)

  let rec function remove (a : 'a)
                          (eq : 'a -> 'a -> bool)
                          (c : list 'a) : list 'a
  =
     match c with
     | Nil -> Nil
     | Cons e tl ->
       if eq e a
       then remove a eq tl
       else Cons e (remove a eq tl)
     end

  let ghost function diff (c1 c2 : list 'a)
  = Fset.diff (elements c1) (elements c2)

  let ghost function subset (c1 c2 : list 'a)
  = Fset.subset (elements c1) (elements c2)

  predicate is_empty (c : list int) = forall m : int. not (mem m c)

  let function nth (i : int) (default : 'a) (c : list 'a) : 'a
  requires { 0 <= i < length c }
  = match nth i c with
    | Some v -> v
    | None -> default
    end

  (* should not be ghost *)
  let ghost function sum (c : list 'a) (f : 'a -> int)
  = FsetSum.sum (elements c) f

  let rec fold (f : {'a} -> 'k -> 'a)
               (acc : {'a})
               (l : list 'k) : 'a
  variant { l } =
  match l with
  | Cons e tl -> fold f (f acc e) tl
  | Nil -> acc
  end

end

theory Sum

  use int.Int
  use list.List

  use Asset

  type storage
  type asset

  function f storage (list asset) int : int

  function sum (list asset) int int : int

  axiom Sum_def_empty :
    forall c : list asset, i j : int.
    j <= i -> sum c i j = 0

  axiom Sum_def_non_empty :
    forall s : storage, c: list asset, i j : int.
    i < j -> sum c i j = f s c i + sum c (i+1) j

  lemma Sum_right_extension:
    forall s : storage, c : list asset, i j : int.
    i < j -> sum c i j = sum c i (j-1) + f s c (j-1)

  lemma Sum_transitivity :
    forall c : list asset, i k j : int. i <= k <= j ->
    sum c i j = sum c i k + sum c k j

  lemma Sum_eq :
    forall s : storage, c1 c2 : list asset, i j : int.
    (forall k : int. i <= k < j -> f s c1 k = f s c2 k) -> sum c1 i j = sum c2 i j

end


(*theory When

  use Contract
  use list.List
  use set.Fset

  use Asset

  type storage
  type asset

  val function test env {storage} {asset} : bool

  let rec function when (e : env) (s : storage) (c : list asset) : list asset
  ensures { forall e : env, s : storage, a : asset.
                mem a result <-> test e s a }
  ensures { subset result c }
  ensures { forall i j : int. i <> j -> not ((nth i result) = (nth j result)) }
  =
  match c with
  | Nil -> Nil
  | Cons a tl ->
    if test e s a
    then Cons a (when e s tl)
    else when e s tl
  end


end*)