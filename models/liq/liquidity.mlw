theory Liquidity

 (* BASIC TYPES -------------------------------------------------*)
 (* type bool *)
 (* type int *)
 use int.Int

 type nat
 type tez
 type string
 type bytes
 type timestamp
 type key
 (*type key_hash*)
 type signature
 type operation
 type address

 (* CONSTRUCTORS *)
 val mktez int : tez

 (* COMPOSITE TYPES ----------------------------------------------------------*)

 (* type list *)
 use list.List
 (* type set *)
 use set.Fset
 (* type map *)
 use map.Map
 (* type option *)
 use option.Option
 (* variant *)
 type lvariant 'a 'b = Left 'a | Right 'b

 let predicate is_left (v : lvariant 'a 'b)
 ensures { result <-> exists a : 'a. v = Left a }
 = match v with Left _ -> true | Right _ -> false end

 let predicate is_right (v : lvariant 'a 'b)
 ensures { result <-> exists b : 'b. v = Right b }
 = match v with Left _ -> false | Right _ -> true end

 (* tuple *)
 let get_0_2 (v : ('a , 'b)) : 'a = let (a,_) = v in a
 let get_1_2 (v : ('a , 'b)) : 'b = let (_,b) = v in b

 let get_0_3 (v : ('a , 'b , 'c)) : 'a = let (a,_,_) = v in a
 let get_1_3 (v : ('a , 'b , 'c)) : 'b = let (_,b,_) = v in b
 let get_2_3 (v : ('a , 'b , 'c)) : 'c = let (_,_,c) = v in c

 let get_0_4 (v : ('a , 'b , 'c , 'd)) : 'a = let (a,_,_,_) = v in a
 let get_1_4 (v : ('a , 'b , 'c , 'd)) : 'b = let (_,b,_,_) = v in b
 let get_2_4 (v : ('a , 'b , 'c , 'd)) : 'c = let (_,_,c,_) = v in c
 let get_3_4 (v : ('a , 'b , 'c , 'd)) : 'd = let (_,_,_,d) = v in d

 let get_0_5 (v : ('a , 'b , 'c , 'd , 'e)) : 'a = let (a,_,_,_,_) = v in a
 let get_1_5 (v : ('a , 'b , 'c , 'd , 'e)) : 'b = let (_,b,_,_,_) = v in b
 let get_2_5 (v : ('a , 'b , 'c , 'd , 'e)) : 'c = let (_,_,c,_,_) = v in c
 let get_3_5 (v : ('a , 'b , 'c , 'd , 'e)) : 'd = let (_,_,_,d,_) = v in d
 let get_4_5 (v : ('a , 'b , 'c , 'd , 'e)) : 'e = let (_,_,_,_,e) = v in e

 (* etc *)

 (* COMPARISON ---------------------------------------------------------------*)

 val function neq (x y : nat)       : bool ensures { result <-> x = y }
 val function zeq (x y : tez)       : bool ensures { result <-> x = y }
 val function seq (x y : string)    : bool ensures { result <-> x = y }
 val function beq (x y : bytes)     : bool ensures { result <-> x = y }
 val function teq (x y : timestamp) : bool ensures { result <-> x = y }
 val function keq (x y : key)       : bool ensures { result <-> x = y }
 val function aeq (x y : address)   : bool ensures { result <-> x = y }

 val function nlt (x y : nat)       : bool
 val function zlt (x y : tez)       : bool
 val function slt (x y : string)    : bool
 val function blt (x y : bytes)     : bool
 val function tlt (x y : timestamp) : bool
 val function klt (x y : key)       : bool
 val function alt (x y : address)   : bool

 val function ngt (x y : nat)       : bool
 val function zgt (x y : tez)       : bool
 val function sgt (x y : string)    : bool
 val function bgt (x y : bytes)     : bool
 val function tgt (x y : timestamp) : bool
 val function kgt (x y : key)       : bool
 val function agt (x y : address)   : bool

 val function nle (x y : nat)       : bool
 val function zle (x y : tez)       : bool
 val function sle (x y : string)    : bool
 val function ble (x y : bytes)     : bool
 val function tle (x y : timestamp) : bool
 val function kle (x y : key)       : bool
 val function ale (x y : address)   : bool

 val function nge (x y : nat)       : bool
 val function zge (x y : tez)       : bool
 val function sge (x y : string)    : bool
 val function bge (x y : bytes)     : bool
 val function tge (x y : timestamp) : bool
 val function kge (x y : key)       : bool
 val function age (x y : address)   : bool

 val function nnq (x y : nat)       : bool ensures { result <-> not x = y }
 val function znq (x y : tez)       : bool ensures { result <-> not x = y }
 val function snq (x y : string)    : bool ensures { result <-> not x = y }
 val function bnq (x y : bytes)     : bool ensures { result <-> not x = y }
 val function tnq (x y : timestamp) : bool ensures { result <-> not x = y }
 val function knq (x y : key)       : bool ensures { result <-> not x = y }
 val function anq (x y : address)   : bool ensures { result <-> not x = y }

 (* OPERATIONS ---------------------------------------------------------------*)

end
