module Miles

  use int.Int
  use mach.int.UInt32
  use ref.Ref

  use set.Fset
  use set.FsetComprehension
  use set.FsetSum
  use set.FsetNth
  use sum.Sum

  use cml4.Types
  use cml4.Contract
  use cml4.Collection

  use array.Array

  type mile = key
  type owner = key

  type storage = {
    mutable miles            : set mile;
    mutable mile_amounts     : collection int;
    mutable mile_expirations : collection date;
    mutable owners           : set owner;
    mutable owner_miles      : collection (set mile);
  }

  axiom Amount_gt0 : forall s : storage, m : mile.
  Collection.get s.mile_amounts m > 0

  let function get_mile   (s : storage) (k : key)  : mile = k
  let function get_amount (s : storage) (m : mile) : int = Collection.get s.mile_amounts m
  let function get_expiration (s : storage) (m : mile) : date = Collection.get s.mile_expirations m

  function get_arr_amount (s : storage) (a : array mile) (i : int) : int =
  get_amount s a[i]

  let function get_owner (s : storage) (a : address) : owner = a

  let function get_miles (s : storage) (o : owner) : set mile
  = Map.get s.owner_miles o

  (* Owner.miles is a partition of s.miles *)

  axiom Owners_miles_part_1 : forall s : storage, m : mile, o : owner.
    Fset.mem o s.owners ->
    let miles = get_miles s o in
    Fset.mem m miles -> Fset.mem m s.miles

  axiom Owners_miles_part_2 : forall s : storage, m : mile.
    exists o : owner.
    let miles = get_miles s o in
    Fset.mem m s.miles -> Fset.mem m miles

  let remove_miles (o : owner) (m : mile) (s:storage) : unit
  requires { mem m s.miles }
  ensures  { FsetSum.sum (old s).miles (get_amount (old s)) =
      (FsetSum.sum s.miles (get_amount s)) + get_amount s m }
  ensures  { forall x:mile. mem x s.miles <-> (mem x (old s).miles /\ x <> m) }
  =
    s.miles       <- Fset.remove m s.miles;
    let miles = get_miles s o in
    let new_miles = remove m miles in
    s.owner_miles <- Collection.set s.owner_miles o new_miles

  let set_amount (m : mile) (a : int) (s : storage) : unit
  requires { mem m s.miles }
  requires { a > 0 }
  ensures  { FsetSum.sum (old s).miles (get_amount (old s)) =
      (FsetSum.sum s.miles (get_amount s)) - a + get_amount (old s) m }
  ensures { (old s).miles = s.miles }
  = s.mile_amounts <- Collection.set s.mile_amounts m a

  (* Transactions  ***********************************************************)

 val function filter_by_expiration (s : storage) (d:date) (miles : set mile) : array mile
  reads { s, d, miles }
  ensures { forall i : int. 0 <= i < length result -> get_expiration s result[i] > d }
  ensures { forall i : int. 0 <= i < length result -> mem result[i] miles }
  ensures { forall i j : int. i <> j -> result[i] <> result[j] }

  meta "compute_max_steps" 1_000_000

  axiom Sum_def_specific :  forall s : storage, a : array mile, i : int.
    0 < i < length a ->
    Contract.sum a (get_arr_amount s) i (length a) =
    Contract.sum a (get_arr_amount s) (i-1) (length a) - (get_arr_amount s a (i-1))

  let consume (e : env) (s : storage) (owner : address) (nbmiles : int) : transfers
  requires { nbmiles > 0 }
  requires { let o = get_owner s owner in Fset.mem o s.owners }
  requires { forall m : mile, s : storage. get_amount s m > 0 }
  requires {
     let o = get_owner s owner in
     let miles = get_miles s o in
     let l = filter_by_expiration s (now e) miles in
     Contract.sum l (get_arr_amount s) 0 (length l) >= nbmiles
  }
  ensures { forall m:mile.
     mem m (diff (old s).miles s.miles) -> get_expiration s m > (now e)
  }
  ensures { FsetSum.sum (old s).miles (get_amount (old s)) =
            (FsetSum.sum s.miles (get_amount s)) + nbmiles }

  ensures { Fset.is_empty (Fset.diff s.miles (old s).miles) }

  (* cml 'invariant (mile.project(not mile.amount))) *)
  ensures { forall m : mile. Fset.mem m s.miles /\ Fset.mem m (old s).miles ->
    get_expiration s m = get_expiration (old s) m }

  = let remainder = ref nbmiles in
    let o = get_owner s owner in
    let miles = get_miles s o in
    let l = filter_by_expiration s (now e) miles in
    try
      for i = 0 to (length l) - 1 do
      (* helps for the membership precondition of set_amouunt: *)
      invariant { forall k:int. i <= k < length l -> mem l[k] s.miles }
      (* removed miles are in l: *)
      invariant {  forall m:mile.
         mem m (diff (old s).miles s.miles) -> exists k:int. 0 <= k < i /\ l[k] = m }
      (* remainder bounds: *)
      invariant { 0 <= !remainder <= Contract.sum l (get_arr_amount s) i (length l) }
      (* right amount spent invariant *)
      invariant { FsetSum.sum (old s).miles (get_amount (old s)) =
        FsetSum.sum s.miles (get_amount s) + nbmiles - !remainder }
      (* no added mile *)
      invariant   { Fset.is_empty (Fset.diff s.miles (old s).miles) }
        let m = l[i] in
        if get_amount s m > !remainder
        then
          (
          set_amount m (get_amount s m - !remainder) s;
          remainder := 0;
           raise Break)
        else if get_amount s m = !remainder
        then
          (remainder := 0;
           remove_miles o m s;
           raise Break)
        else
          (remainder := !remainder - get_amount s m;
           remove_miles o m s)
      done;
    with Break -> assert { !remainder = 0 }; ()
    end;
    assert { !remainder = 0 };
    Contract.empty

end