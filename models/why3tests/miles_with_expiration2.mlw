module Miles

  use int.Int
  use mach.int.UInt32
  use ref.Ref
  use array.Array

  use cml2.Types
  use cml2.Contract
  use cml2.Asset

  use set.Set
  use map.Map

  type mile = key
  type owner = key

  type storage = {
    mutable miles            : set mile;
    mutable mile_amounts     : map mile int;
    mutable mile_expirations : map mile date;
    mutable owners           : set owner;
    mutable owner_miles      : map owner (set mile);
  }

  clone cml2.Asset as Mile with type storage = storage,
                           type asset   = mile,
                           predicate le = (<=)

  function get_mile   (s : storage) (k : key)  : mile = k
  function get_amount (s : storage) (m : mile) : int = Map.get s.mile_amounts m
  function get_expiration (s : storage) (m : mile) : date = Map.get s.mile_expirations m

  function get_owner (s : storage) (a : address) : owner = a
  function get_miles (s : storage) (o : owner) : set mile = Map.get s.owner_miles o

  function get_array_amount (s : storage) (a : array mile) (i : int) : int =
    let m = a.elts i in get_amount s m

  let ghost remove_miles (*(o : owner)*) (m : mile) (s:storage) : unit
    requires { mem m s.miles }
    ensures  { Mile.sum_col (old s).miles get_amount =
      (Mile.sum_col s.miles get_amount) + get_amount s m }
    ensures  { diff (old s).miles s.miles = singleton m } =
    s.miles <- remove m s.miles

  let ghost set_amount (m : mile) (a : int) (s : storage) : unit
  requires { mem m s.miles }
  requires { a > 0 }
  ensures  { Mile.sum_col (old s).miles get_amount =
      (Mile.sum_col s.miles get_amount) - a + get_amount s m } =
  (*s.mile_amounts <- Map.set s.mile_amounts m a*)
  s.mile_amounts <- s.mile_amounts[ m <- a ]

  (* partition property *)
(*  axiom miles_partition : forall s:storage, o:owner, m:mile.
           is_mile m s <-> (is_owner o s /\ Mile.mem m o.miles)

  axiom miles_subset : forall s:storage, o:owner.
           Set.subset o.miles s.mile_col
*)
  (* Transactions  ***********************************************************)

  function filter_expiration (d : date) (s : storage) (m : mile) : bool =
      get_expiration s m > d

  let ghost consume (e : env) (s : storage) (owner : address) (nbmiles : int) : transfers
  requires { nbmiles > 0 }
  requires {
     let o = get_owner s owner in
     let l = Mile.when (filter_expiration (now e)) s.miles in
     Mile.sum l get_array_amount 0 (length l) >= nbmiles
  }

  ensures { forall m:mile.
     mem m (diff (old s).miles s.miles) -> get_expiration s m > (now e)
  }

  ensures {
     Mile.sum_col (old s).miles get_amount = (Mile.sum_col s.miles get_amount) + nbmiles
  }

  = let remainder = ref nbmiles in
    (*let o = get_owner s owner in*)
    let l = Mile.when (filter_expiration (now e)) s.miles in
    try
       for i = 0 to length l - 1 do
       invariant { forall m:mile.
          mem m (diff (old s).miles s.miles) -> get_expiration s m > (now e)
       }
       invariant { nbmiles = (Mile.sum l get_array_amount 0 i) + !remainder }
       invariant { Mile.sum_col (old s).miles get_amount =
          (Mile.sum_col s.miles get_amount) + (Mile.sum l get_array_amount 0 i)}
       invariant { !remainder >= 0 }
          let m = l.elts i in
          if get_amount s m > !remainder
          then
             (remainder := 0;
              set_amount m (get_amount s m - !remainder) s;
              raise Break)
          else if get_amount s m = !remainder
          then
             (remainder := 0;
              remove_miles (*o*) m s;
              raise Break)
          else
             (remainder := !remainder - get_amount s m;
              remove_miles (*o*) m s)
       done;
    with Break -> assert { !remainder = 0 }; ()
    end;
    assert { !remainder = 0 };
    Contract.empty

end