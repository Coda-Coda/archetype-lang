module Miles

  use int.Int
  use mach.int.UInt32
  use ref.Ref
  use set.Fset
  use array.Array

  use cml.Types
  use cml.Contract
  use cml.Asset

  (* Mile *********************************************************************)

  type mile = {
     mile_id        : int;
     amount         : int;
     expiration     : date;
  } invariant { amount > 0 }

  (* projections *)
  function mile_key    (m : mile) : int  = m.mile_id
  function mile_amount (m : mile) : int  = m.amount
  function mile_sort   (m : mile) : date = m.expiration

  function get_amount (c:array mile) (i : int) : int = let mile = c[i] in
                                                        mile.amount
  (* declare mile as an Asset *)
  clone cml.Asset as Mile with type      key   = int,
                               type      sort  = date,
                               type      asset = mile,
                               function  akey  = mile_key,
                               function  asort = mile_sort,
                               predicate kle   = (<=)

  (* Owner ********************************************************************)

  type owner = {
     addr    : address;
     miles   : Mile.collection;
  }

  (* projections *)
  function owner_key   (o : owner) : int             = o.addr
  function owner_miles (o : owner) : Mile.collection = o.miles

  (* declare mile as an Asset *)
  clone cml.Asset as Owner with type      key   = int,
                                type      sort  = int,
                                type      asset = owner,
                                function  akey  = owner_key,
                                function  asort = owner_key,
                                predicate kle   = (<=)

  (* Storage *****************************************************************)

  type storage = {
    mutable milec   : Mile.collection;
    mutable ownerc  : Owner.collection;
  }

  function is_mile (m : mile) (s : storage) : bool  = Mile.mem m s.milec
  function is_owner (o : owner) (s : storage) : bool = Owner.mem o s.ownerc

  function get_owner (addr : address) (s : storage) : owner = Owner.get addr s.ownerc

  let remove_miles (o : owner) (m : mile) (s:storage) : unit
    requires { Mile.mem m s.milec }
    ensures  { Mile.sum_col (old s).milec mile_amount =
      (Mile.sum_col s.milec mile_amount) + mile_amount m }
    ensures  { Mile.diff (old s).milec s.milec = Fset.singleton m } =
    s.milec <- Mile.remove m s.milec

  let ghost set_amount (m : mile) (a : int) (s : storage) : unit
  requires { Mile.mem m s.milec }
  requires { a > 0 }
  ensures  { Mile.sum_col (old s).milec mile_amount =
      (Mile.sum_col s.milec mile_amount) - a + mile_amount m } =
    let new_m = {
        mile_id = mile_key m;
        amount  = a;
        expiration = mile_sort m;
    } in
    s.milec <- Mile.remove m s.milec;
    s.milec <- Mile.add new_m s.milec

  (* partition property *)
(*  axiom miles_partition : forall s:storage, o:owner, m:mile.
           is_mile m s <-> (is_owner o s /\ Mile.mem m o.miles)

  axiom miles_subset : forall s:storage, o:owner.
           Set.subset o.miles s.miles
*)
  (* Transactions  ***********************************************************)

  function by_expiration (d : date) (m : mile) : bool = m.expiration > d

  let ghost consume (e : env) (s : storage) (owner : address) (nbmiles : int) : transfers
  requires { nbmiles > 0 }
  requires {
     let o = get_owner owner s in
     let l = Mile.when (by_expiration (now e)) o.miles in
     Mile.sum l get_amount 0 (length l) >= nbmiles
  }

  ensures { forall m:mile.
     Mile.mem m (Mile.diff (old s).milec s.milec) -> m.expiration > (now e)
  }

  ensures {
     Mile.sum_col (old s).milec mile_amount = (Mile.sum_col s.milec mile_amount) + nbmiles
  }

  = let remainder = ref nbmiles in
    let o = get_owner owner s in
    let l = Mile.when (by_expiration (now e)) s.milec in
    try
       for i = 0 to length l - 1 do
       invariant { forall k:int. 0 <= k < length l -> Mile.mem l[i] s.milec }
       invariant { forall m:mile.
          Mile.mem m (Mile.diff (old s).milec s.milec) -> m.expiration > (now e)
       }
       invariant { nbmiles = (Mile.sum l get_amount 0 i) + !remainder }
       invariant { Mile.sum_col (old s).milec mile_amount =
          (Mile.sum_col s.milec mile_amount) + (Mile.sum l get_amount 0 i) }
       invariant { !remainder >= 0 }
          let m = l[i] in
          if m.amount > !remainder
          then
             (remainder := 0;
              set_amount m (m.amount - !remainder) s;
              raise Break)
          else if m.amount = !remainder
          then
             (remainder := 0;
              remove_miles o m s;
              raise Break)
          else
             (remainder := !remainder - m.amount;
              remove_miles o m s)
       done;
    with Break -> assert { !remainder = 0 }; ()
    end;
    assert { !remainder = 0 };
    empty

end