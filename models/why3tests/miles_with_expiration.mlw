module Miles

  use int.Int

  use cml.Types
  use cml.Contract
  use cml.Asset

  (* Mile *********************************************************************)
  type mile = {
     mile_id        : int;
     mutable amount : uint;
     expiration     : date;
  } invariant { amount > 0 }

  function mile_key (m : mile) : int = m.mile_id
  function mile_sort (m : mile) : date = m.expiration

  (* declare mile as an Asset *)
  clone cml.Asset as Mile with type      key   = int,
                               type      sort  = date,
                               type      asset = mile,
                               function  akey  = mile_key,
                               function  asort = mile_sort,
                               predicate kle   = (<=)

  (* Owner ********************************************************************)
  type owner = {
     owner_id        : int;
     mutable miles   : Mile.collection;
  }

  function owner_key (o : owner) : int = o.owner_id

  (* declare mile as an Asset *)
  clone cml.Asset as Owner with type      key   = int,
                                type      sort  = int,
                                type      asset = owner,
                                function  akey  = owner_key,
                                function  asort = owner_key,
                                predicate kle   = (<=)

  (****************************************************************************)

  type storage = {
    mutable mile_coll   : Mile.collection;
    mutable owner_coll  : Owner.collection;
  }

  function is_mile (m : mile) (s : storage) : bool  = Mile.mem m s.mile_coll
  function is_owner (o : owner) (s : storage) : bool = Owner.mem o s.owner_coll

  axiom miles_partition : forall s:storage, m:mile.
           is_mile m s <-> (exists o:owner. is_owner o s /\ Mile.mem m o.miles)

end