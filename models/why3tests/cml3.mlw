theory Types

  use int.Int
  use mach.int.UInt32

  (* default type mapping *)
  type key     = int
  type role    = int
  type address = int
  type uint    = uint32
  type tez     = uint32
  type date    = int

  constant max_uint : int = UInt32.max_uint32

  exception Break
  exception NotFound

end

theory Contract

  use Types
  use int.Int
  use mach.int.UInt32
  use list.List
  use list.Append
  use set.Fset
  use set.FsetNth
  use set.FsetSum
  use array.Array

  (* currency transfer during transaction *)
  type transfer = {
     destination : address;
     amount      : tez;
  }

  type transfers = list transfer

  let empty : transfers = Nil

  type env = {
     mutable balance_ : tez;
     (* transaction env *)
     transferred_     : tez;
     caller_          : address;
     now_             : date;
  }

  let function balance (e: env) : tez = e.balance_

  let function transferred (e : env) : tez = e.transferred_

  let function caller (e : env) : address = e.caller_

  let function now (e : env) : date = e.now_

  let update_balance (e : env)
    requires { transferred e + balance e <= max_uint }
    ensures  { balance e = old (balance e) + (transferred e)}
  =
    let sum = e.balance_ + e.transferred_ in
    e.balance_ <- sum

  let exec_transfer (e : env) (a : address) (c : tez) (ops : transfers) : transfers
    requires { c <= balance e }
    ensures  { old (balance e) = (balance e) + c }
  =
    e.balance_ <- e.balance_ - c;
    let transfer = { destination = a; amount = c } in
    ops ++ (Cons transfer Nil)

end

(* non ghost map *)
module Ngmap

  use int.Int

  type ngmap 'value = int -> 'value

  let function get (f: ngmap 'value) (x: int) : 'value = f x

  let function set (f: ngmap 'value) (x: int) (v: 'value) : ngmap 'value =
    fun (y : int) -> if y = x then v else f y

end

(* Set with :
   mem
   lenght
   add
   remove
   diff
   nth
  implemented with list type
 *)
theory Asset

  use list.List
  use list.Length
  use list.Elements
  use list.Append
  use list.Nth
  use set.Fset
  use option.Option
  use int.Int

  use Types
  use Contract
  use Ngmap

  predicate mem (a : 'a) (c : list 'a) = Mem.mem a c

  let function length (c : list 'a) = length c

  let function add (a : 'a) (c : list 'a) = c ++ (Cons a Nil)

  let rec function remove (a : 'a)
                          (eq : 'a -> 'a -> bool)
                          (c : list 'a) : list 'a
  =
     match c with
     | Nil -> Nil
     | Cons e tl ->
       if eq e a
       then remove a eq tl
       else Cons e (remove a eq tl)
     end

  let ghost function diff (c1 c2 : list 'a)
  = Fset.diff (elements c1) (elements c2)

  let ghost function subset (c1 c2 : list 'a)
  = Fset.subset (elements c1) (elements c2)

  predicate is_empty (c : list 'a) = forall m : 'a. not (mem m c)

  let function nth (i : int) (default : 'a) (c : list 'a) : 'a
  requires { 0 <= i < length c }
  = match nth i c with
    | Some v -> v
    | None -> default
    end

  (* should not be ghost *)
  let ghost function sum (c : list 'a) (f : 'a -> int)
  = FsetSum.sum (elements c) f

end

theory Sum

  use int.Int
  use list.List

  use Asset

  type storage
  type asset

  function f storage (list asset) int : int

  function sum (list asset) int int : int

  axiom Sum_def_empty :
    forall c : list asset, i j : int.
    j <= i -> sum c i j = 0

  axiom Sum_def_non_empty :
    forall s : storage, c: list asset, i j : int.
    i < j -> sum c i j = f s c i + sum c (i+1) j

  lemma Sum_right_extension:
    forall s : storage, c : list asset, i j : int.
    i < j -> sum c i j = sum c i (j-1) + f s c (j-1)

  lemma Sum_transitivity :
    forall c : list asset, i k j : int. i <= k <= j ->
    sum c i j = sum c i k + sum c k j

  lemma Sum_eq :
    forall s : storage, c1 c2 : list asset, i j : int.
    (forall k : int. i <= k < j -> f s c1 k = f s c2 k) -> sum c1 i j = sum c2 i j

end
