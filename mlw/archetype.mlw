theory Types

  use int.Int

  (* default type mapping *)
  type key       = int
  type key_hash  = int
  type role      = int
  type address   = int
  type tez       = int
  type date      = int
  type astring   = int
  type bytes     = int
  type signature = int
  type chain_id  = int

  exception Break
  exception NotFound
  exception KeyExist
  exception InvalidCaller
  exception InvalidCondition
  exception NoTransfer
  exception InvalidState
  exception Invalid string
end

module Utils
  use int.Int
  use Types

  (* ------------------------------------------------------------------------ *)
  (* Tuples *)

  let function fst (a : (int, int)) : int
  =
  match a with
  | (l,_) -> l
  end

  let function snd (a: (int, int)) : int
  =
  match a with
  | (_,r) -> r
  end

  (* ------------------------------------------------------------------------ *)
  (* Math *)

  let function abs (a : int) : int
  ensures { result >= 0 }
  =
  if a >= 0 then a else -a

  use int.EuclideanDivision

  let function floor (a : (int,int)) : int
  requires { not (snd a) = 0 }
  =
  match a with
  | (n,d) ->
   if d > 0 then
     div n d
   else
     (div n d) - 1
  end

  let function ceil (a : (int,int)) : int
  requires { not (snd a) = 0 }
  =
  match a with
  | (n,d) ->
   if d > 0 then
     (div n d) + 1
   else
     div n d
  end

  (* ------------------------------------------------------------------------ *)
  (* Rational *)

  type op_cmp =
   | OpCmpLt
   | OpCmpLe
   | OpCmpGt
   | OpCmpGe

  let function rat_cmp (op : op_cmp) (lhs : (int, int)) (rhs : (int, int)) : bool
  =  let a = (fst lhs) * (snd rhs) in
     let b = (snd lhs) * (fst rhs) in
     let pos = (fst lhs) * (fst rhs) > 0 in
     match op with
     | OpCmpLt -> if pos then
                    a < b
                  else
                    a > b
     |OpCmpLe -> if pos then
                   a <= b
                 else
                   a >= b
     |OpCmpGt -> if pos then
                   a > b
                 else
                   a < b
     |OpCmpGe -> if pos then
                   a >= b
                 else
                   a <= b
     end

  let function rat_eq (lhs : (int, int)) (rhs : (int, int)) : bool
  = fst lhs * snd rhs = fst rhs * snd lhs

  type op_arith =
   | OpArithPlus
   | OpArithMinus
   | OpArithMult
   | OpArithDiv

  let function rat_arith (op : op_arith) (lhs : (int, int)) (rhs : (int, int)) : (int, int)
  =  match op with
     | OpArithPlus -> (((fst lhs) * (snd rhs)) + ((snd rhs) * (snd lhs)) , (snd lhs) * (snd rhs))
     | OpArithMinus -> (((fst lhs) * (snd rhs)) - ((snd rhs) * (snd lhs)) , (snd lhs) * (snd rhs))
     | OpArithMult -> ((fst lhs) * (fst rhs) , (snd lhs) * (snd rhs))
     | OpArithDiv -> ((fst lhs) * (snd rhs) , (snd lhs) * (fst rhs))
     end

  let function div_tez (a : tez) (b : tez) : tez = div a b

  let function rat_tez (c : (int, int)) (t : tez) : tez
  requires { not (snd c) = 0 }
  =  div ((abs (fst c)) * t) (abs (snd c))

  let function abs_rat (a : (int, int)) : (int, int)
  =
  match a with
  | (l,r) -> (abs l, abs r)
  end

  let function int_to_rat (a : int) : (int, int)
  = (a,1)

  let function rat_uminus (r : (int, int)) : (int, int)
  =
  match r with
  | (l,r) -> (-l,r)
  end

  let function rat_min (a : (int, int)) (b : (int, int)) : (int, int)
  = if rat_cmp OpCmpLe a b then a else b

  let function rat_max (a : (int, int)) (b : (int, int)) : (int, int)
  = if rat_cmp OpCmpLe a b then b else a

  let function rat_dur (a : (int, int)) (b : int) : int
  = div ((fst a) * b) (snd a)


  (* ----------------------------------------------------------------------- *)
  (* String *)

  let function str_concat (s1 : astring) (s2 : astring) : astring = s1 + s2

  let function substring  (_ : astring) (_ : int) (_ : int) = 0

  let function str_length (_ : astring) : int = 0

  let function byt_concat (b1 : bytes) (b2 : bytes) : bytes = b1 + b2

  (* ----------------------------------------------------------------------- *)
  (* Option *)
  use option.Option

  let function issome (v : option 'a) : bool
  =
  match v with
  | Some _ -> true
  | None -> false
  end

  let function isnone (v : option 'a) : bool
  =
  match v with
  | Some _ -> false
  | None -> true
  end

  let getopt (o : option 'a) : 'a
  raises { NotFound }
  =
  match o with
  | Some v -> v
  | None -> raise NotFound
  end

  (* ----------------------------------------------------------------------- *)
  (* Set *)
  use list.List as S
  use list.Length as SL

  let rec function set_add s a =
  match s with
  | S.Nil -> S.Cons a s
  | S.Cons e ts -> if a = e then ts else S.Cons e (set_add ts a)
  end

  let rec function set_remove s a =
  match s with
  | S.Nil -> S.Nil
  | S.Cons e ts -> if a = e then (set_remove ts a) else S.Cons e (set_remove ts a)
  end

  let rec function set_contains s a =
  match s with
  | S.Nil -> false
  | S.Cons e ts -> a = e || set_contains ts a
  end

  let function set_length l = SL.length l

  (* ----------------------------------------------------------------------- *)
  (* List *)
  use list.List as A
  use list.Length as L
  use list.Nth as N

  let function lcard l = L.length l

  let lnth l n
  raises { NotFound }
  =
  match N.nth l n with
  | Some e -> e
  | None -> raise NotFound
  end

  let rec function lcontains l a
  =
  match l with
  | A.Nil -> false
  | A.Cons e tl -> a = e || lcontains tl a
  end

  let function lprepend l a
  = A.Cons a l

  (* ----------------------------------------------------------------------- *)
  (* crypto *)
  let function blake2b (b : bytes) : bytes = b
  let function sha256 (b : bytes) : bytes = b
  let function sha512 (b : bytes) : bytes = b
  let function hash_key (_k : key) : bytes = 0
  let check_signature (_k : key) (_s : signature) (_b : bytes) = true

  (* ----------------------------------------------------------------------- *)
  (* serialization *)
  let function pack (_x : 'a) : bytes = 0
  let function unpack (_b : bytes) : option 'a = None

  (* ----------------------------------------------------------------------- *)
  (* bool *)
  let function neq_bool (a : bool) (b : bool) : bool = not (a && b)

  (* ------------------------------------------------------------------------ *)
  axiom inv_pack_unpack: forall x : bytes. exists a : int. unpack(x) = Some(a) -> pack(a) = x

end

module Trace

  use Types
  use list.List
  use list.Mem
  use option.Option

  type _asset
  type _entry
  type _field

  type _action =
  | TrRm_ _asset
  | TrAdd_ _asset
  | TrUpdate_ _field
  | TrGet_ _asset
  | TrIterate _asset
  | TrTransfer int
  | TrCallContract int

  type _traces = list _action

  predicate changes_performed_by (changes : _traces) (tr : _traces) (p : bool) =
  forall x : _action.
  mem x tr ->
  mem x changes ->
  p

  predicate performed_by  (tr : _traces) (p : bool) =
  forall x : _action.
  mem x tr ->
  p

end

theory Contract

  use Types
  use int.Int
  use list.List
  use list.Mem as L

  type transfer = {
     destination_ : address;
     amount_      : tez;
  }

  let mk_transfer (d : address) (a : tez) : transfer = {
    destination_ = d;
    amount_ = a;
  }

  type transfers = list transfer

  let no_transfer : transfers = Nil

  let mk_call (c : address) : transfer = {
    destination_ = c;
    amount_ = 0;
  }

end

(* source : http://toccata.lri.fr/gallery/insertion_sort_list.fr.html *)
module InsertionSort

  type elt
  val predicate le elt elt

  clone relations.TotalPreOrder with
    type t = elt, predicate rel = le, axiom .
  clone export list.Sorted with
    type t = elt, predicate le  = le, goal Transitive.Trans

  use list.List
  use list.Permut

  let rec function insert (x: elt) (l: list elt) : list elt
    requires { sorted l }
    ensures  { sorted result }
    ensures  { permut (Cons x l) result }
    variant  { l }
  = match l with
    | Nil -> Cons x Nil
    | Cons y r -> if le x y then Cons x l else Cons y (insert x r)
    end

  let rec function insertion_sort (l: list elt) : list elt
    ensures { sorted result }
    ensures { permut l result }
    variant { l }
  = match l with
    | Nil -> Nil
    | Cons x r -> insert x (insertion_sort r)
    end

end

module View
  use Types
  use int.Int
  use list.List
  use list.Distinct as D
  use list.Mem as M
  use list.Length as L
  use option.Option

  (* ------------------------------------------------------------------------ *)
  type view = {
    content : list key
  } invariant {
    D.distinct content
  } by {
    content = Nil;
  }

  (* ------------------------------------------------------------------------ *)
  let function mk (l : list key) : view
  requires { D.distinct l }
  = { content = l }

  (* ------------------------------------------------------------------------ *)
  let function elts (v : view) : list key
  ensures { D.distinct result }
  = content v

   (* ------------------------------------------------------------------------ *)
  let function empty = { content = Nil }

  (* ------------------------------------------------------------------------ *)
  predicate is_empty (v : view) = v.content = Nil

  (* ------------------------------------------------------------------------ *)
  let function mem (k: key) (v: view) : bool
  ensures { result <-> M.mem k v.content }
  =
  let rec internal_mem (l : list key) : bool
  variant { l }
  ensures { result <-> M.mem k l }
  =
  match l with
    | Nil      -> false
    | Cons e tl -> k = e || internal_mem tl
  end in
  internal_mem v.content

  (* ------------------------------------------------------------------------ *)
  let function card (v : view) : int
  ensures { result = L.length v.content }
  =
  L.length v.content

  (* ------------------------------------------------------------------------ *)
  predicate subset (v1 v2 : view) = forall k. mem k v1 -> mem k v2

  (* ------------------------------------------------------------------------ *)
  let function contains (k : key) (v : view)
  ensures { result <-> M.mem k v.content }
  = mem k v

  (* ------------------------------------------------------------------------ *)
  let function nth (i : int) (v : view) : option key
  ensures {
    0 <= i < card v ->
    exists k. result = Some k /\ mem k v
  }
  =
  let rec internal_nth (i : int) (l : list key) : option key
  variant { l }
  ensures {
    0 <= i < L.length l ->
    exists k. result = Some k /\ M.mem k l
  }
  =
  match l with
  | Cons k tl -> if i = 0 then Some k else internal_nth (i - 1) tl
  | Nil -> None
  end in
  internal_nth i v.content

  (* ------------------------------------------------------------------------ *)
  lemma nth_singleton: forall k. nth 0 (mk (Cons k Nil)) = Some k

  (* ------------------------------------------------------------------------ *)
   (* keep first i elements *)
  let function keep (i : int) (v : view) : view
  ensures { forall k. mem k result -> mem k v }
  ensures {
    0 <= i <= card v ->
    card result = i
  }
  =
  let rec function internal_keep (k : int) (l : list key) : list key
  requires { D.distinct l }
  variant { v }
  ensures { D.distinct result }
  ensures { forall k. M.mem k result -> M.mem k l }
  ensures {
    0 <= i <= L.length l ->
    L.length result = i
  }
  =
  match l with
  | Cons e tl ->
    if k < i then
      Cons e (internal_keep (k+1) tl)
    else Nil
  | Nil -> Nil
  end in
  mk (internal_keep 0 v.content)

  (* ------------------------------------------------------------------------ *)
  lemma keep_none: forall v. keep 0 v = empty

  (* ------------------------------------------------------------------------ *)
  lemma keep_all: forall v : view, i : int.
  i >= card v -> keep i v = v

  (* ------------------------------------------------------------------------ *)
  (* vdrop first i elements *)
  let function drop (i : int) (v : view) : view
  ensures { forall k. mem k result -> mem k v }
  ensures {
    0 <= i <= card v ->
    card result = card v - i
  }
  =
  let rec function internal_drop (k : int) (l : list key) : list key
  requires { D.distinct l }
  variant { v }
  ensures { D.distinct result }
  ensures { forall k. M.mem k result -> M.mem k l }
  ensures {
    0 <= i <= L.length l ->
    L.length result = i
  }
  =
  match l with
  | Cons e tl ->
    if k < i then
      internal_drop (k+1) tl
    else
      Cons e (internal_drop (k+1) tl)
  | Nil -> Nil
  end in
  mk (internal_drop 0 v.content)

  (* ------------------------------------------------------------------------ *)
  lemma drop_none: forall v. drop 0 v = v


  (* ------------------------------------------------------------------------ *)
  lemma drop_all: forall v. drop (card v) v = empty


end

module Set
  use Types
  use int.Int
  use list.List
  use list.Length as L
  use list.Append as A
  use list.Distinct as D
  use list.Mem as M
  use option.Option
  use fset.Undup
  use fset.ListFilter

  (* ------------------------------------------------------------------------ *)
  type t = abstract {}
  (* ------------------------------------------------------------------------ *)
  val function fkey  t : key
  (* ------------------------------------------------------------------------ *)
  val function feq t t : bool
  (* ------------------------------------------------------------------------ *)
  let predicate ple t1 t2 = fkey t1 <= fkey t2
  (* ------------------------------------------------------------------------ *)
  clone InsertionSort as IS with type elt = t,
                                 val le = ple

  let rec function fmem (a : t) (l : list t) : bool =
    match l with
    | Nil -> false
    | Cons e tl -> feq a e || fmem a tl
    end

  let rec function undup (l : list t) : list t =
    match l with
    | Nil -> Nil
    | Cons e tl ->
        if fmem e tl then undup tl else Cons e (undup tl)
    end

  let function norm (l : list t) : list t =
    IS.insertion_sort (undup l)

  clone  fset.FSet    as F  with type t     = t,
                                 val  eqt   = feq,
                                 val  norm  = norm,
                                 axiom .

  (* fkey is injective *)
  predicate key_injective (l : list t) =
    forall a1 a2.
    mem a1 l -> mem a2 l ->
    fkey a1 = fkey a2 -> feq a1 a2

  type set = {
    content : F.fset
  } invariant {
    key_injective (F.content content)
  } by {
    content = F.fset0;
  }

  (* ------------------------------------------------------------------------ *)
  predicate (==) (c1 c2 : set) = F.(==) c1.content c2.content

  (* ------------------------------------------------------------------------ *)
  let function mk (s : F.fset) : set
  requires { key_injective (F.content s) }
  ensures { F.(==) s (content result) }
  ensures { content result = s }
  = { content = s }

  (* ------------------------------------------------------------------------ *)
  lemma mk_content: forall c.
  (mk (c.content)) == c

  (* ------------------------------------------------------------------------ *)
  lemma content_mk [@rewrite] :
  forall s. key_injective (F.content s) -> (content (mk s)) = s

  (* ------------------------------------------------------------------------ *)
  let function elts (c : set) : list t
  ensures { IS.sorted result }
  ensures { D.distinct result }
  (* ensures { F.sorted result } *)
  =
  F.content c.content

  (* Set theory ************************************************************* *)

  (* ------------------------------------------------------------------------ *)
  let function empty : set = mk F.fset0

  (* ------------------------------------------------------------------------ *)
  predicate is_empty (c : set) = is_nil (elts c)

  (* ------------------------------------------------------------------------ *)
  predicate mem (a : t) (c : set) = F.fmem a c.content

  (* ------------------------------------------------------------------------ *)
  lemma mem_empty : is_empty empty

  (* ------------------------------------------------------------------------ *)
  let function card (c : set) : int
  ensures { result >= 0 }
  = F.fcard c.content

  (* ------------------------------------------------------------------------ *)
  (* shall this be a lemma ? *)
  axiom eqEquality : forall c1 c2. c1 == c2 <-> c1 = c2

  (* ------------------------------------------------------------------------ *)
  lemma mk_injective: forall s1 s2.
  key_injective (F.content s1) -> key_injective (F.content s2) ->
  mk s1 == mk s2 -> F.(==) s1 s2

   (* ------------------------------------------------------------------------ *)
  lemma cons_key_injective : forall a l.
  key_injective l ->
  (forall e. M.mem e l -> fkey e <> fkey a) ->
  key_injective (Cons a l)

  (* ------------------------------------------------------------------------ *)
  predicate subset (c1 c2 : set) = F.fsubset c1.content c2.content

  (* ------------------------------------------------------------------------ *)
  function diff (c1 c2 : set) : set
  = mk (F.fsetD c1.content c2.content)

  (* ------------------------------------------------------------------------ *)
  function inter (c1 c2 : set) : set
  = mk (F.fsetI c1.content c2.content)

  (* ------------------------------------------------------------------------ *)
  function union (c1 c2 : set) : set
  = mk (F.fsetU c1.content c2.content)

  (* Singleton ************************************************************** *)

  (* ------------------------------------------------------------------------ *)
  lemma one_unary_injective: forall a. key_injective (Cons a Nil)

  (* ------------------------------------------------------------------------ *)
  let function singleton (a : t) : set = mk (F.mk (Cons a Nil))

  (* ------------------------------------------------------------------------ *)
  lemma mem_singleton: forall a1 a2 : t.
  mem a1 (singleton a2) -> a1 = a2

  (* ------------------------------------------------------------------------ *)
  lemma card_singleton: forall a : t. card (singleton a) = 1

  (* ------------------------------------------------------------------------ *)
  lemma subset_singleton: forall a : t, c : set.
  subset (singleton a) c <-> mem a c

   (* ------------------------------------------------------------------------ *)
  let rec function internal_get (l : list t) (k : key) : option t
  requires { D.distinct l }
  requires { key_injective l }
  variant { l }
  ensures { forall e. result = Some e -> fkey e = k }
  ensures { result = None -> forall e. M.mem e l -> fkey e <> k }
  =
  match l with
  | Cons e tl ->
    if fkey e = k
    then Some e
    else internal_get tl k
  | Nil -> None
  end

  (* ------------------------------------------------------------------------ *)
  lemma cons_internal_get : forall k x a l.
  D.distinct l ->
  key_injective l ->
  fkey x <> k ->
  internal_get l k = Some a ->
  internal_get (Cons x l) k = Some a

  (* ------------------------------------------------------------------------ *)
  let function get (c : set) (k : key) : option t
  ensures { forall e. result = Some e -> fkey e = k }
  ensures { result = None -> forall e. mem e c -> fkey e <> k }
  = internal_get (elts c) k

  (* ------------------------------------------------------------------------ *)
  let add (s : set) (a : t) : set
  requires { not (mem a s) }
  ensures { mem a result }
  ensures { result == union (singleton a) s }
  = mk (F.mk (Cons a (elts s)))  (* normalisation is done by F.mk *)

  (* ------------------------------------------------------------------------ *)
  let remove (s : set) (k : key) : set
  ensures { forall e. get s k = Some e -> result == diff s (singleton e) }
  ensures { get s k = None -> result == s }
  =
  let rec internal_remove (l : list t) : list t
  requires { D.distinct l }
  requires { key_injective l }
  variant { l }
  ensures { D.distinct result }
  ensures { key_injective result }
  ensures { (exists e. fkey e  = k /\ M.mem e l) -> L.length result = L.length l - 1 }
  ensures { forall a. M.mem a result <-> M.mem a (filter (fun x -> fkey x <> k) l) }
  = match l with
  | Cons e tl ->
    if fkey e = k then tl
    else Cons e (internal_remove tl)
  | Nil -> Nil
  end in
  mk (F.mk (internal_remove (F.content (content s))))

end

module Field
  use int.Int
  use Set
  use Types

  let function id (x : key) = x
  let function eq (x1 : key) (x2 : key) = x1 = x2

  clone Set as S with type t = int,
                      val fkey = id,
                      val feq = eq

end

module AssetCollection
  use Types
  use int.Int
  use list.List
  use list.Length as L
  use list.Append as A
  use list.Distinct as D
  use list.Mem as M
  use option.Option
  use fset.Undup
  use fset.ListFilter
  use View as V
   (* ------------------------------------------------------------------------ *)
  type t = abstract {}        (* asset type           *)
  (* ------------------------------------------------------------------------ *)
  val function fkey  t : key  (* asset key function   *)
  (* ------------------------------------------------------------------------ *)
  val function feq t t : bool (* asset equality *)
  (* ------------------------------------------------------------------------ *)
  clone Set as S with type t = t,
                      val fkey = fkey,
                      val feq  = feq

  type collection = S.set

  (* Collection API ********************************************************* *)

  (* ------------------------------------------------------------------------ *)
  let set (c : collection) (k : key) (a : t) : collection
  requires { (* S.contains k c *) S.get c k <> None }
  requires { fkey a = k }
  ensures { S.get result k = Some a }
  =
  let rec internal_set (l : list t) : list t
  requires { S.key_injective l }
  variant { l }
  ensures { S.key_injective result }
  ensures { S.internal_get result k = Some a }
  =
  match l with
  | Cons e tl ->
    if fkey e = k
    then Cons a (internal_set tl)
    else Cons e (internal_set tl)
  | Nil -> Nil
  end in
  S.mk (S.F.mk (internal_set (S.elts c)))

  (* ------------------------------------------------------------------------ *)
  predicate list_subset (l1 : list t) (l2 : list t) = forall e. M.mem e l1 -> M.mem e l2

  let function view_to_list (v : V.view) (c : collection) : list t
  ensures { D.distinct result }
  ensures { S.key_injective result }
  =
  let rec function internal_view_to_list (l : list t) : list t
  requires { D.distinct l }
  requires { S.key_injective l }
  variant { l }
  ensures { list_subset result l }
  ensures { D.distinct result }
  ensures { S.key_injective result }
  =
  match l with
  | Cons e tl ->
    if V.mem (fkey e) v then
      Cons e (internal_view_to_list tl)
    else
      internal_view_to_list tl
  | Nil -> Nil
  end in
  internal_view_to_list (S.elts c)

  (* ------------------------------------------------------------------------ *)
  let rec function internal_list_to_view (l : list t) : list key
  requires { D.distinct l }
  requires { S.key_injective l }
  variant { l }
  ensures { D.distinct result }
  ensures { forall k. M.mem k result <-> exists e. M.mem e l /\ fkey e = k }
  ensures { L.length result = L.length l }
  =
  match l with
  | Cons e tl -> Cons (fkey e) (internal_list_to_view tl)
  | Nil -> Nil
  end

  (* ------------------------------------------------------------------------ *)
  let function list_to_view (l : list t) : V.view
  requires { D.distinct l }
  requires { S.key_injective l }
  ensures { forall k. V.mem k result <-> exists e. M.mem e l /\ fkey e = k }
  ensures { V.card result = L.length l }
  = V.mk (internal_list_to_view l)

  (* ------------------------------------------------------------------------ *)
  let rec function to_view (c : collection) : V.view
  ensures { forall k. V.mem k result <-> exists e. S.mem e c /\ fkey e = k }
  ensures { V.card result = S.card c }
  =
  list_to_view (S.elts c)

  goal sanity_check : false
end

module Sort
  use list.List
  use int.Int
  use Types
  use View as V

  (* ------------------------------------------------------------------------ *)
  type t
  (* ------------------------------------------------------------------------ *)
  type collection
  (* ------------------------------------------------------------------------ *)
  val function cmp : t -> t -> bool
  (* ------------------------------------------------------------------------ *)
  val function view_to_list : V.view -> collection -> list t
  (* ------------------------------------------------------------------------ *)
  val function list_to_view : list t -> V.view

  (* ------------------------------------------------------------------------ *)
  let predicate ple (a b : t) = cmp a b

  (* ------------------------------------------------------------------------ *)
  clone InsertionSort as IS with type elt = t,
                                 val le = ple

  let function sort (v : V.view) (c : collection)
  =
  list_to_view (IS.insertion_sort (view_to_list v c))

end

module Sum

  use  int.Int
  use  list.List
  use  option.Option
  use  View as V

  (* ------------------------------------------------------------------------ *)
  type t
  (* ------------------------------------------------------------------------ *)
  type collection

  (* ------------------------------------------------------------------------ *)
  val function field t : int
  (* ------------------------------------------------------------------------ *)
  val function get collection int : option t

  (* ------------------------------------------------------------------------ *)
  let function sum (v : V.view) (c : collection) : int
  =
  let rec function internal_sum (l : list int) (acc : int) : int
  variant { l }
  =
    match l with
     | Cons k tl ->
      match get c k with
      | Some e -> internal_sum tl (acc + field e)
      | None -> internal_sum tl acc
      end
     | Nil -> acc
    end
  in
  internal_sum (V.elts v) 0

  (* ------------------------------------------------------------------------ *)
  lemma sum_empty:
    forall v : V.view, c : collection. V.card v = 0 -> sum v c = 0

  (* ------------------------------------------------------------------------ *)
  lemma sum_singleton: forall k : int, a : t, c : collection.
  get c k = Some a ->
  sum (V.mk (Cons k Nil)) c = field a

end


theory Lib

  use export int.Int
  use export option.Option
  use export Utils
  use export Types
  use export Contract
  use export AssetCollection
  use export Trace

end