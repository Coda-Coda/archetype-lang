module Auction_zilliqa_storage
  use archetype.Lib
  
  use list.List as L
  
  use archetype.Field as F
  
  use archetype.View as V
  
  type _asset =
   | APending_return
  
  type _entry =
   | EPlace_bid
   | EWithdraw
   | EEndAuction
  
  type _field =
   | FHighest_bid
   | FHighest_bidder
   | FBeneficiary
   | FAuction_start
   | FAuction_end
   | FIncumbent
   | F_val
  
  clone archetype.Trace as Tr with type _asset = _asset,
                                   type _entry = _entry,
                                   type _field = _field
  
  type state =
   | Open
   | Closed
  
  type pending_return = {
    incumbent : address;
    _val : tez 
  }
  
  let function eq_pending_return_key (k1 : address) (k2 : address) : bool
  =  str_eq k1 k2
  
  let function eq_pending_return (a1 : pending_return) (a2 : pending_return) : bool
  =  (let a1_incumbent = a1.incumbent in
     let a2_incumbent = a2.incumbent in
     str_eq a1_incumbent a2_incumbent && let a1__val = a1._val in
     let a2__val = a2._val in
     a1__val = a2__val)
  
  let mk_default_pending_return () : pending_return
  =  {
       incumbent = "";
       _val = 0
     }
  
  clone archetype.View as View_pending_return with type tk = address,
                                                   val eqk = eq_pending_return_key
  
  clone archetype.Field as Field_pending_return with type tk = address,
                                                     val eqk = eq_pending_return_key,
                                                     type view = View_pending_return.view,
                                                     val vmk = View_pending_return.mk,
                                                     val velts = View_pending_return.elts,
                                                     val vcontains = View_pending_return.contains
  
  clone archetype.Collection as Pending_return with type tk = address,
                                                    val eqk = eq_pending_return_key,
                                                    type t = pending_return,
                                                    val keyt = incumbent,
                                                    val eqt = eq_pending_return,
                                                    type view = View_pending_return.view,
                                                    val vmk = View_pending_return.mk,
                                                    val velts = View_pending_return.elts,
                                                    val vcontains = View_pending_return.contains,
                                                    type field = Field_pending_return.field,
                                                    val felts = Field_pending_return.elts
  
  lemma pending_return_extensionality:
    forall a1 a2 : pending_return.
    eq_pending_return a1 a2 ->
    a1 = a2 
  
  type _storage = {
    mutable highest_bid : tez;
    mutable highest_bidder : address;
    mutable beneficiary : address;
    mutable auction_start : int;
    mutable auction_end : int;
    mutable state : state;
    mutable _pending_return_assets : Pending_return.collection;
    mutable _pending_return_assets_added : Pending_return.collection;
    mutable _pending_return_assets_removed : Pending_return.collection;
    mutable call_count_withdraw : int;
    mutable _ops : L.list operation;
    mutable _balance : tez;
    _transferred : tez;
    _caller : address;
    _source : address;
    _now : date;
    _chainid : chain_id;
    _selfaddress : address;
    _entry : option _entry;
    mutable _tr : Tr._traces 
  } invariant {
    [@expl:highest_is_not_pending]
    not (View_pending_return.contains highest_bidder (Pending_return.to_view _pending_return_assets)) 
  }
  invariant {
    [@expl:highest_is_highest]
    forall pr : pending_return.
    Pending_return.mem pr _pending_return_assets ->
    ((pr._val <= highest_bid) && (not (str_eq pr.incumbent highest_bidder)))   
  } by {
    highest_bid = 0;
    highest_bidder = "tz1Lc2qBKEWCBeDU8npG6zCeCqpmaegRi6Jg";
    beneficiary = "tz1bfVgcJC4ukaQSHUe1EbrUd5SekXeP9CWk";
    auction_start = 1546300800;
    auction_end = 1548979200;
    state = Open;
    _pending_return_assets = Pending_return.from_list (L.Nil);
    _pending_return_assets_added = Pending_return.empty;
    _pending_return_assets_removed = Pending_return.empty;
    call_count_withdraw = 0;
    _ops = L.Nil;
    _balance = 0;
    _transferred = 0;
    _caller = "";
    _source = "";
    _now = 0;
    _chainid = 0;
    _selfaddress = "";
    _entry = None;
    _tr = L.Nil 
  }
  
  val _s : _storage
  
  let transfer (a : int) (t : address) : unit
  ensures {
    [@expl:transfer_post_1]
    _s._balance = ((old _s)._balance - a)  
  }
  =  _s._ops <- L.Cons (_mk_transfer t a) _s._ops;
     _s._balance <- _s._balance - a
  
  let call (t : address) (a : tez) (n : string) (l : L.list string) : unit
  =  _s._ops <- L.Cons (_mk_call t a n l) _s._ops
  
  let mk_operation (a : tez) (e : entrysig) (l : L.list string) : unit
  =  _s._ops <- L.Cons (_mk_operation a e l) _s._ops
  
  let get_pending_return (k : address) : pending_return
  raises { NotFound ->
           (Pending_return.get k _s._pending_return_assets) = None  }
  ensures {
    [@expl:get_pending_return_post_1]
    (Pending_return.get k _s._pending_return_assets) = (Some result) 
  }
  ensures {
    [@expl:get_pending_return_post_2]
    result.incumbent = k  
  }
  =  match Pending_return.get k _s._pending_return_assets with
     | Some e -> e
     | _ -> raise NotFound 
     end
  
  let set_pending_return (asset_id : address) (new_asset : pending_return) : unit
  raises { NotFound ->
           (Pending_return.get asset_id _s._pending_return_assets) = None  }
  ensures {
    [@expl:set_pending_return_post1]
    (Pending_return.get asset_id _s._pending_return_assets) = (Some new_asset) 
  }
  ensures {
    [@expl:set_pending_return_post2]
    forall k : address.
    k <> asset_id ->
    (Pending_return.get k _s._pending_return_assets) = (Pending_return.get k (old _s)._pending_return_assets)   
  }
  =  match Pending_return.get asset_id _s._pending_return_assets with
     | Some _ -> _s._pending_return_assets <- Pending_return.set asset_id new_asset _s._pending_return_assets
     | _ -> raise NotFound 
     end
  
  let add_pending_return (new_asset : pending_return) : unit
  raises { KeyExist ->
           (Pending_return.get new_asset.incumbent (old _s)._pending_return_assets) = None  }
  ensures {
    [@expl:add_pending_return_post_1]
    (Pending_return.get new_asset.incumbent (old _s)._pending_return_assets) = None 
  }
  ensures {
    [@expl:add_pending_return_post_2]
    forall k : address.
    k <> new_asset.incumbent ->
    (Pending_return.get new_asset.incumbent _s._pending_return_assets) = (Pending_return.get new_asset.incumbent (old _s)._pending_return_assets)  
  }
  ensures {
    [@expl:add_pending_return_post_3]
    (Pending_return.get new_asset.incumbent _s._pending_return_assets) = (Some new_asset) 
  }
  ensures {
    [@expl:add_pending_return_post_4]
    (Pending_return.get new_asset.incumbent (old _s)._pending_return_assets_added) = None 
  }
  ensures {
    [@expl:add_pending_return_post_5]
    forall k : address.
    k <> new_asset.incumbent ->
    (Pending_return.get new_asset.incumbent _s._pending_return_assets_added) = (Pending_return.get new_asset.incumbent (old _s)._pending_return_assets_added)  
  }
  ensures {
    [@expl:add_pending_return_post_6]
    (Pending_return.get new_asset.incumbent _s._pending_return_assets_added) = (Some new_asset)  
  }
  =  match Pending_return.get new_asset.incumbent _s._pending_return_assets with
     | Some _ -> raise KeyExist
     | _ -> _s._pending_return_assets <- Pending_return.add new_asset _s._pending_return_assets;
            _s._pending_return_assets_added <- Pending_return.add new_asset _s._pending_return_assets_added 
     end
  
  let remove_pending_return (a : address) : unit
  ensures {
    [@expl:remove_pending_return_post1]
    forall k : address.
    k <> a ->
    (Pending_return.get a _s._pending_return_assets) = (Pending_return.get a (old _s)._pending_return_assets)  
  }
  ensures {
    [@expl:remove_pending_return_post2]
    (Pending_return.get a _s._pending_return_assets) = None 
  }
  ensures {
    [@expl:remove_pending_return_post3]
    forall k : address.
    k <> a ->
    (Pending_return.get a _s._pending_return_assets_removed) = (Pending_return.get a (old _s)._pending_return_assets_removed)  
  }
  ensures {
    [@expl:remove_pending_return_post4]
    forall r : pending_return.
    (Pending_return.get a (old _s)._pending_return_assets) = (Some r) ->
    (Pending_return.get a _s._pending_return_assets_removed) = (Some r)   
  }
  =  match Pending_return.get a _s._pending_return_assets with
     | Some e -> _s._pending_return_assets_removed <- Pending_return.add e _s._pending_return_assets_removed;
                 _s._pending_return_assets <- Pending_return.remove a _s._pending_return_assets
     | _ -> () 
     end
end
module Auction_zilliqa
  use archetype.Lib
  
  use list.List as L
  
  use Auction_zilliqa_storage
  
  let place_bid () : unit
  raises { InvalidCondition }
  raises { NotFound }
  raises { KeyExist }
  raises { Invalid }
  requires {
    [@expl:entry_require]
    _s._entry = (Some EPlace_bid) 
  }
  requires {
   [@expl:empty_trace]
   _s._tr = L.Nil  
  }
  =  if not (((_s.auction_start <= _s._now) && (_s._now <= _s.auction_end))) then raise InvalidCondition;
     if View_pending_return.contains (_s._caller) (Pending_return.to_view _s._pending_return_assets) then (
       let bid = (get_pending_return (_s._caller))._val in
       let new_bid = bid + (_s._transferred) in
       if new_bid > _s.highest_bid then (
         (add_pending_return ({
            incumbent = _s.highest_bidder;
            _val = _s.highest_bid
          });
          _s._tr <- L.Cons (Tr.TrAdd_ APending_return) _s._tr;
          remove_pending_return (_s._caller);
          _s._tr <- L.Cons (Tr.TrRm_ APending_return) _s._tr;
          _s.highest_bid <- new_bid;
          _s.highest_bidder <- _s._caller) )
       else (
         let pending_return_ = get_pending_return (_s._caller) in
         let pending_return_ = {
           incumbent = pending_return_.incumbent;
           _val = new_bid
         } in
         (set_pending_return (_s._caller) pending_return_;
          _s._tr <- L.Cons (Tr.TrUpdate_ F_val) _s._tr) ) )
     else (
       if str_eq (_s._caller) _s.highest_bidder then (
         _s.highest_bid <- _s.highest_bid + (_s._transferred) )
       else (
         if _s._transferred > _s.highest_bid then (
           (add_pending_return ({
              incumbent = _s.highest_bidder;
              _val = _s.highest_bid
            });
            _s._tr <- L.Cons (Tr.TrAdd_ APending_return) _s._tr;
            _s.highest_bid <- _s._transferred;
            _s.highest_bidder <- _s._caller) )
         else (
           raise (Invalid "no update") ) ) )
  
  let withdraw () : unit
  raises { InvalidCondition }
  requires {
    [@expl:entry_require]
    _s._entry = (Some EWithdraw) 
  }
  requires {
   [@expl:empty_trace]
   _s._tr = L.Nil  
  }
  ensures {
    [@expl:o1]
    View_pending_return.contains (_s._caller) (Pending_return.to_view _s._pending_return_assets) ->
    _s.call_count_withdraw = 0  
  }
  ensures {
    [@expl:o2]
    _s.call_count_withdraw <= 1  
  }
  =  if not (View_pending_return.contains (_s._caller) (Pending_return.to_view _s._pending_return_assets)) then raise InvalidCondition;
     transfer (get_pending_return (_s._caller))._val (_s._caller);
     remove_pending_return (_s._caller);
     _s._tr <- L.Cons (Tr.TrRm_ APending_return) _s._tr;
     _s.call_count_withdraw <- _s.call_count_withdraw + 1
  
  let endAuction () : unit
  raises { InvalidState }
  requires {
    [@expl:entry_require]
    _s._entry = (Some EEndAuction) 
  }
  requires {
   [@expl:empty_trace]
   _s._tr = L.Nil  
  }
  =  match _s.state with
     | Open -> if _s._now > _s.auction_end then (transfer _s.highest_bid _s.beneficiary;
                                                 _s.state <- Closed)
     | _ -> raise InvalidState 
     end
end

